{
  "Flappy-Bird-Qt\\source\\common.h": {
    "includes": [
      "#include <QApplication>\r\n",
      "#include \"vector.h\"\r\n"
    ],
    "functions": []
  },
  "Flappy-Bird-Qt\\source\\main.cpp": {
    "includes": [
      "#include \"common.h\"\r\n",
      "#include <QApplication>\r\n",
      "#include <QTime>\r\n",
      "#include \"MainWindow/MainWindow.h\"\r\n"
    ],
    "functions": [
      {
        "function_name": "main(int argc, char **argv)",
        "params": "(int argc, char **argv)",
        "body": "{\r\n    QApplication app(argc, argv);\r\n\r\n    Q_INIT_RESOURCE(Resource);\r\n    QCoreApplication::setOrganizationName(\"fuzun\");\r\n    QCoreApplication::setApplicationName(GAME_NAME);\r\n    QCoreApplication::setApplicationVersion(GAME_VERSION);\r\n\r\n    qsrand(QTime::currentTime().msec());\r\n\r\n    MainWindow mainWindow;\r\n    mainWindow.show();\r\n\r\n    return app.exec();\r\n}",
        "calls": [
          "Q_INIT_RESOURCE",
          "QCoreApplication::setOrganizationName",
          "QCoreApplication::setApplicationName",
          "QCoreApplication::setApplicationVersion",
          "qsrand",
          "QTime::currentTime().msec",
          "QTime::currentTime",
          "mainWindow.show",
          "app.exec"
        ]
      }
    ]
  },
  "Flappy-Bird-Qt\\source\\vector.h": {
    "includes": [],
    "functions": [
      {
        "function_name": "Vector2(void)",
        "params": "(void)",
        "body": "{\r\n        reset();\r\n    }",
        "calls": [
          "reset"
        ]
      },
      {
        "function_name": "Vector2(T x_, T y_)",
        "params": "(T x_, T y_)",
        "body": "{\r\n        x = x_;\r\n        y = y_;\r\n    }",
        "calls": []
      },
      {
        "function_name": "Vector2(const Vector2 &vector2)",
        "params": "(const Vector2 &vector2)",
        "body": "{\r\n        x = vector2.x;\r\n        y = vector2.y;\r\n    }",
        "calls": []
      },
      {
        "function_name": "makeVector2(T x_, T y_)",
        "params": "(T x_, T y_)",
        "body": "{\r\n        Vector2 vector2;\r\n        vector2.x = x_;\r\n        vector2.y = y_;\r\n        return vector2;\r\n    }",
        "calls": []
      },
      {
        "function_name": "*makeVector2Temporary(T x_, T y_)",
        "params": "",
        "body": "{\r\n        static Vector2 *vector2 = new Vector2(x_, y_);\r\n        return vector2;\r\n    }",
        "calls": []
      },
      {
        "function_name": "operator + (const Vector2 &vector2)",
        "params": "(const Vector2 &vector2)",
        "body": "{\r\n        Vector2 vector2_;\r\n        vector2_.x = x + vector2.x;\r\n        vector2_.y = y + vector2.y;\r\n        return vector2_;\r\n    }",
        "calls": []
      },
      {
        "function_name": "operator - (const Vector2 &vector2)",
        "params": "(const Vector2 &vector2)",
        "body": "{\r\n        Vector2 vector2_;\r\n        vector2_.x = x - vector2.x;\r\n        vector2_.y = y - vector2.y;\r\n        return vector2_;\r\n    }",
        "calls": []
      },
      {
        "function_name": "operator * (const Vector2 &vector2)",
        "params": "(const Vector2 &vector2)",
        "body": "{\r\n        int result;\r\n        result = (x * vector2.x) + (y * vector2.y);\r\n        return result;\r\n    }",
        "calls": []
      },
      {
        "function_name": "& operator = (const Vector2 &vector2)",
        "params": "",
        "body": "{\r\n        if(this != &vector2)\r\n        {\r\n            x = vector2.x;\r\n            y = vector2.y;\r\n        }\r\n        return *this;\r\n    }",
        "calls": []
      },
      {
        "function_name": "operator == (const Vector2 &vector2)",
        "params": "(const Vector2 &vector2)",
        "body": "{\r\n        if(x == vector2.x && y == vector2.y)\r\n            return true;\r\n        else\r\n            return false;\r\n    }",
        "calls": []
      },
      {
        "function_name": "operator != (const Vector2 &vector2)",
        "params": "(const Vector2 &vector2)",
        "body": "{\r\n        return !(*this == vector2);\r\n    }",
        "calls": []
      },
      {
        "function_name": "dotProduct(const Vector2 &vector2)",
        "params": "(const Vector2 &vector2)",
        "body": "{\r\n        return (*this * vector2);\r\n    }",
        "calls": []
      },
      {
        "function_name": "dotProduct(const Vector2 &vector2_1, const Vector2 &vector2_2)",
        "params": "(const Vector2 &vector2_1, const Vector2 &vector2_2)",
        "body": "{\r\n        return (vector2_1 * vector2_2);\r\n    }",
        "calls": []
      },
      {
        "function_name": "reset(void)",
        "params": "(void)",
        "body": "{\r\n        x = (T)0;\r\n        y = (T)0;\r\n    }",
        "calls": []
      },
      {
        "function_name": "reset(Vector2 &vector2)",
        "params": "(Vector2 &vector2)",
        "body": "{\r\n        vector2.x = (T)0;\r\n        vector2.y = (T)0;\r\n    }",
        "calls": []
      }
    ]
  },
  "Flappy-Bird-Qt\\source\\AI\\AI.cpp": {
    "includes": [
      "#include \"AI.h\"\r\n",
      "#include <QString>\r\n",
      "#include <QTimer>\r\n",
      "#include <QGraphicsLineItem>\r\n",
      "#include <QGraphicsTextItem>\r\n",
      "#include <QGraphicsPixmapItem>\r\n",
      "#include \"Game/Game.h\"\r\n",
      "#include \"Scene/Scene.h\"\r\n",
      "#include \"Bird/Bird.h\"\r\n"
    ],
    "functions": [
      {
        "function_name": "AI::AI(class Game *parent_game, int aiNeuronCount, int aiBatchSize, int aiEpochs, int aiUpdateInterval, float aiClickThreshold)",
        "params": "(class Game *parent_game, int aiNeuronCount, int aiBatchSize, int aiEpochs, int aiUpdateInterval, float aiClickThreshold)",
        "body": "{\r\n    predictClicked = false;\r\n    curEpoch = 0;\r\n    updateCount = 0;\r\n\r\n    epochReset = false;\r\n    trainingFinished = true;\r\n\r\n    vector.x = -game->getScreenWidth();\r\n    vector.y = -game->getScreenHeight();\r\n\r\n    vectorLine = new QGraphicsLineItem();\r\n    QPen linePen;\r\n    linePen.setColor(Qt::darkRed);\r\n    linePen.setWidth(2);\r\n    vectorLine->setPen(linePen);\r\n\r\n    birdSpeedVectorLine = new QGraphicsLineItem();\r\n    QPen linePen2;\r\n    linePen2.setColor(Qt::darkMagenta);\r\n    linePen2.setWidth(2);\r\n    birdSpeedVectorLine->setPen(linePen2);\r\n\r\n    predictionBar = new QGraphicsLineItem();\r\n    QPen linePen3;\r\n    linePen3.setColor(Qt::yellow);\r\n    linePen3.setWidth(5);\r\n    predictionBar->setPen(linePen3);\r\n\r\n    aiInfo = new QGraphicsTextItem();\r\n    aiInfo->setPlainText(QString(\"***AI***\\n\\nNeuron count: %1\\nBatch size: %2\\nEpochs: %3\\nUpdate interval: %4\\n\").arg(QString::number(neuronCount), QString::number(batchSize), QString::number(epochs), QString::number(updateInterval)));\r\n    aiInfo->setPos(0, game->scene->ground->y() + 35);\r\n\r\n    game->scene->addItem(aiInfo);\r\n    game->scene->addItem(vectorLine);\r\n    game->scene->addItem(birdSpeedVectorLine);\r\n    game->scene->addItem(predictionBar);\r\n\r\n    birdSpeed = new QTimer();\r\n    birdSpeed->setInterval(10);\r\n    birdOldY = game->scene->bird->y();\r\n    QObject::connect(birdSpeed, &QTimer::timeout, [this]() {\r\n        // Calculate instant speed of the bird\r\n        birdSpeedY = -((game->scene->bird->y() - birdOldY) / birdSpeed->interval());\r\n        birdOldY = game->scene->bird->y();\r\n    });\r\n\r\n    updater = new QTimer();\r\n    updater->setInterval(updateInterval);\r\n    QObject::connect(updater, &QTimer::timeout, [this]() {\r\n        if(game->isGameFinished() || !game->isGameStarted())\r\n        {\r\n            vectorLine->setVisible(false);\r\n            birdSpeedVectorLine->setVisible(false);\r\n            predictionBar->setVisible(false);\r\n            birdSpeed->stop();\r\n            return;\r\n        }\r\n        vectorLine->setVisible(true);\r\n        birdSpeedVectorLine->setVisible(true);\r\n        if(game->aiPlays)\r\n            predictionBar->setVisible(true);\r\n        birdSpeed->start();\r\n        update();\r\n    });\r\n    updater->start();\r\n\r\n    network << tiny_dnn::fully_connected_layer(3, neuronCount) << tiny_dnn::tanh_layer();\r\n    network << tiny_dnn::fully_connected_layer(neuronCount, neuronCount) << tiny_dnn::tanh_layer();\r\n    network << tiny_dnn::fully_connected_layer(neuronCount, neuronCount) << tiny_dnn::tanh_layer();\r\n    network << tiny_dnn::fully_connected_layer(neuronCount, neuronCount) << tiny_dnn::tanh_layer();\r\n    network << tiny_dnn::fully_connected_layer(neuronCount, 1) << tiny_dnn::sigmoid_layer();\r\n}",
        "calls": [
          "game->getScreenWidth",
          "game->getScreenHeight",
          "linePen.setColor",
          "linePen.setWidth",
          "vectorLine->setPen",
          "linePen2.setColor",
          "linePen2.setWidth",
          "birdSpeedVectorLine->setPen",
          "linePen3.setColor",
          "linePen3.setWidth",
          "predictionBar->setPen",
          "aiInfo->setPlainText",
          "QString(\"***AI***\\n\\nNeuron count: %1\\nBatch size: %2\\nEpochs: %3\\nUpdate interval: %4\\n\").arg",
          "QString",
          "QString::number",
          "QString::number",
          "QString::number",
          "QString::number",
          "aiInfo->setPos",
          "game->scene->ground->y",
          "game->scene->addItem",
          "game->scene->addItem",
          "game->scene->addItem",
          "game->scene->addItem",
          "birdSpeed->setInterval",
          "game->scene->bird->y",
          "QObject::connect",
          "game->scene->bird->y",
          "birdSpeed->interval",
          "game->scene->bird->y",
          "updater->setInterval",
          "QObject::connect",
          "game->isGameFinished",
          "game->isGameStarted",
          "vectorLine->setVisible",
          "birdSpeedVectorLine->setVisible",
          "predictionBar->setVisible",
          "birdSpeed->stop",
          "vectorLine->setVisible",
          "birdSpeedVectorLine->setVisible",
          "predictionBar->setVisible",
          "birdSpeed->start",
          "update",
          "updater->start",
          "tiny_dnn::fully_connected_layer",
          "tiny_dnn::tanh_layer",
          "tiny_dnn::fully_connected_layer",
          "tiny_dnn::tanh_layer",
          "tiny_dnn::fully_connected_layer",
          "tiny_dnn::tanh_layer",
          "tiny_dnn::fully_connected_layer",
          "tiny_dnn::tanh_layer",
          "tiny_dnn::fully_connected_layer",
          "tiny_dnn::sigmoid_layer"
        ]
      },
      {
        "function_name": "AI::~AI()",
        "params": "()",
        "body": "{\r\n    birdSpeed->stop();\r\n    delete birdSpeed;\r\n    updater->stop();\r\n    delete updater;\r\n    game->scene->removeItem(predictionBar);\r\n    delete predictionBar;\r\n    game->scene->removeItem(birdSpeedVectorLine);\r\n    delete birdSpeedVectorLine;\r\n    game->scene->removeItem(vectorLine);\r\n    delete vectorLine;\r\n    game->scene->removeItem(aiInfo);\r\n    delete aiInfo;\r\n}",
        "calls": [
          "birdSpeed->stop",
          "updater->stop",
          "game->scene->removeItem",
          "game->scene->removeItem",
          "game->scene->removeItem",
          "game->scene->removeItem"
        ]
      },
      {
        "function_name": "AI::update(bool reg)",
        "params": "(bool reg)",
        "body": "{\r\n    int index = game->birdClosestPipe;\r\n    Vector2<qreal> start, end, actual;\r\n\r\n    end.x = game->scene->pipe[0][index]->x() + game->scene->pipe[0][index]->boundingRect().width();\r\n    end.y = ((game->scene->pipe[0][index]->y() + game->scene->pipe[0][index]->boundingRect().height()) + game->scene->pipe[1][index]->y()) / 2.0f;\r\n\r\n    start.x = game->scene->bird->x() + game->scene->bird->boundingRect().width();\r\n    start.y = game->scene->bird->y() + game->scene->bird->boundingRect().height() / 2;\r\n\r\n    vectorLine->setLine(end.x, end.y, start.x, start.y);\r\n\r\n    actual.y = end.y - start.y;\r\n    actual.x = end.x - start.x;\r\n\r\n    float normalX = normalize(actual.x, game->getScreenWidth());\r\n    float normalY = normalize(actual.y, game->getScreenHeight());\r\n    float normalSpeed = normalize(birdSpeedY, game->getScreenHeight());\r\n\r\n    qreal birdMiddle = game->scene->bird->x() + game->scene->bird->boundingRect().width() / 2;\r\n    qreal speedStartY = birdSpeedY >= 0 ? game->scene->bird->y() - 25 : game->scene->bird->y() + game->scene->bird->boundingRect().height() + 25;\r\n    // qreal speedEndY = birdSpeedY >= 0 ? speedStartY - normalSpeed * 10000 : speedStartY - normalSpeed * 10000;\r\n    qreal speedEndY = speedStartY - normalSpeed * 10000;\r\n    birdSpeedVectorLine->setLine(birdMiddle, speedStartY, birdMiddle, speedEndY);\r\n\r\n    tiny_dnn::vec_t i = {{normalX, normalY, birdSpeedY /* normalSpeed */}};\r\n    tiny_dnn::vec_t o = {0.0f};\r\n\r\n    QString text = QString(\"***Pushed Back!***\\n# Vector2D(%1, %2) [to input (correct when output=0.0f)]\\n-> Normalized x: %3 - y: %4)\\n# Bird y speed: %5 [to input]\\n# bool($1$) [to output] -> $2$\\nTotal: %6\\n\").arg(QString::number(actual.x), QString::number(actual.y), QString::number(normalX), QString::number(normalY), QString::number(birdSpeedY), QString::number(updateCount));\r\n\r\n    if(reg)\r\n    {\r\n        input.push_back(i);\r\n        output.push_back(o);\r\n        text.replace(\"$1$\", \"false\").replace(\"$2$\", \"0.0f\");\r\n    }\r\n    else\r\n    {\r\n        text.replace(\"$1$\", \"true\").replace(\"$2$\", \"1.0f\");\r\n    }\r\n\r\n    aiInfo->setPlainText(text);\r\n\r\n    if(game->aiPlays)\r\n    {\r\n        float prediction;\r\n        bool toClick = predictClick(actual, &prediction);\r\n        aiInfo->setPlainText(aiInfo->toPlainText() + QString(\"\\n***AI Plays***\\n#Click Prediction: %1\\n\").arg(QString::number(prediction)));\r\n        if(!predictClicked && toClick)\r\n        {\r\n            predictClicked = true;\r\n            QApplication::processEvents();\r\n            game->clickEvent();\r\n            aiInfo->setPlainText(aiInfo->toPlainText() + QString(\"***[AI CLICK]***\\n\"));\r\n            QTimer::singleShot(50, [this]() {\r\n                predictClicked = false;\r\n                aiInfo->setPlainText(aiInfo->toPlainText().replace(\"***[AI CLICK]***\\n\", \"\"));\r\n            });\r\n        }\r\n        qreal middle = game->scene->ground->y() / 2;\r\n        predictionBar->setLine(10, middle - prediction * middle, 10, middle + prediction * middle);\r\n    }\r\n    ++updateCount;\r\n    return actual;\r\n}",
        "calls": [
          "game->scene->pipe[0][index]->x",
          "game->scene->pipe[0][index]->boundingRect().width",
          "game->scene->pipe[0][index]->boundingRect",
          "game->scene->pipe[0][index]->y",
          "game->scene->pipe[0][index]->boundingRect().height",
          "game->scene->pipe[0][index]->boundingRect",
          "game->scene->pipe[1][index]->y",
          "game->scene->bird->x",
          "game->scene->bird->boundingRect().width",
          "game->scene->bird->boundingRect",
          "game->scene->bird->y",
          "game->scene->bird->boundingRect().height",
          "game->scene->bird->boundingRect",
          "vectorLine->setLine",
          "normalize",
          "game->getScreenWidth",
          "normalize",
          "game->getScreenHeight",
          "normalize",
          "game->getScreenHeight",
          "game->scene->bird->x",
          "game->scene->bird->boundingRect().width",
          "game->scene->bird->boundingRect",
          "game->scene->bird->y",
          "game->scene->bird->y",
          "game->scene->bird->boundingRect().height",
          "game->scene->bird->boundingRect",
          "birdSpeedVectorLine->setLine",
          "QString(\"***Pushed Back!***\\n# Vector2D(%1, %2) [to input (correct when output=0.0f)]\\n-> Normalized x: %3 - y: %4)\\n# Bird y speed: %5 [to input]\\n# bool($1$) [to output] -> $2$\\nTotal: %6\\n\").arg",
          "QString",
          "QString::number",
          "QString::number",
          "QString::number",
          "QString::number",
          "QString::number",
          "QString::number",
          "input.push_back",
          "output.push_back",
          "text.replace(\"$1$\", \"false\").replace",
          "text.replace",
          "text.replace(\"$1$\", \"true\").replace",
          "text.replace",
          "aiInfo->setPlainText",
          "predictClick",
          "aiInfo->setPlainText",
          "aiInfo->toPlainText",
          "QString(\"\\n***AI Plays***\\n#Click Prediction: %1\\n\").arg",
          "QString",
          "QString::number",
          "QApplication::processEvents",
          "game->clickEvent",
          "aiInfo->setPlainText",
          "aiInfo->toPlainText",
          "QString",
          "QTimer::singleShot",
          "aiInfo->setPlainText",
          "aiInfo->toPlainText().replace",
          "aiInfo->toPlainText",
          "game->scene->ground->y",
          "predictionBar->setLine"
        ]
      },
      {
        "function_name": "AI::birdTriggered()",
        "params": "()",
        "body": "{\r\n    if(!(vector.x == -game->getScreenWidth() && vector.y == -game->getScreenHeight()))\r\n    {\r\n        tiny_dnn::vec_t i = {{normalize(vector.x, game->getScreenWidth()), normalize(vector.y, game->getScreenHeight()), birdSpeedY}};\r\n        tiny_dnn::vec_t o = {1.0f};\r\n\r\n        input.push_back(i);\r\n        output.push_back(o);\r\n    }\r\n    vector = update(false);\r\n}",
        "calls": [
          "game->getScreenWidth",
          "game->getScreenHeight",
          "normalize",
          "game->getScreenWidth",
          "normalize",
          "game->getScreenHeight",
          "input.push_back",
          "output.push_back",
          "update"
        ]
      },
      {
        "function_name": "AI::epochUpdate()",
        "params": "()",
        "body": "{\r\n    QApplication::processEvents();\r\n\r\n    curEpoch++;\r\n\r\n    if (curEpoch % 10)\r\n    {\r\n        epochReset = false;\r\n        return;\r\n    }\r\n\r\n    if(!(curEpoch % 70))\r\n        epochReset = true;\r\n\r\n    double loss = network.get_loss<tiny_dnn::cross_entropy>(input, output);\r\n\r\n    if(epochReset)\r\n    {\r\n        aiInfo->setPlainText(\"***Learning from data!***\");\r\n    }\r\n\r\n    aiInfo->setPlainText(aiInfo->toPlainText() + QString(\"\\nepoch: %1 / %2 - loss: %3\").arg(QString::number(curEpoch), QString::number(epochs), QString::number(loss)));\r\n\r\n\r\n    if(curEpoch == epochs)\r\n    {\r\n        aiInfo->setPlainText(aiInfo->toPlainText() + \"\\n***Training has been finished!***\");\r\n        trainingFinished = true;\r\n    }\r\n}",
        "calls": [
          "QApplication::processEvents",
          "network.get_loss<tiny_dnn::cross_entropy>",
          "aiInfo->setPlainText",
          "aiInfo->setPlainText",
          "aiInfo->toPlainText",
          "QString(\"\\nepoch: %1 / %2 - loss: %3\").arg",
          "QString",
          "QString::number",
          "QString::number",
          "QString::number",
          "aiInfo->setPlainText",
          "aiInfo->toPlainText"
        ]
      },
      {
        "function_name": "AI::train()",
        "params": "()",
        "body": "{\r\n    curEpoch = 0;\r\n    aiInfo->setPlainText(\"***Training has been started!***\");\r\n    int fixedBatchSize;\r\n    if(updateCount <= batchSize)\r\n        fixedBatchSize = updateCount;\r\n    else\r\n        fixedBatchSize = batchSize;\r\n\r\n    trainingFinished = false;\r\n    network.fit<tiny_dnn::cross_entropy>(optimization, input, output, fixedBatchSize, epochs, []() {}, [this]() {epochUpdate();});\r\n}",
        "calls": [
          "aiInfo->setPlainText",
          "network.fit<tiny_dnn::cross_entropy>",
          "epochUpdate"
        ]
      },
      {
        "function_name": "AI::normalize(float x, float limit)",
        "params": "(float x, float limit)",
        "body": "{\r\n    return ((x + limit) / limit - 1.0f) * 5.0f;\r\n}",
        "calls": []
      },
      {
        "function_name": "AI::clearData()",
        "params": "()",
        "body": "{\r\n    updateCount = 0;\r\n    input.clear();\r\n    output.clear();\r\n}",
        "calls": [
          "input.clear",
          "output.clear"
        ]
      },
      {
        "function_name": "AI::stopTrain()",
        "params": "()",
        "body": "{\r\n    network.stop_ongoing_training();\r\n    aiInfo->setPlainText(\"***Training has been stopped!***\");\r\n}",
        "calls": [
          "network.stop_ongoing_training",
          "aiInfo->setPlainText"
        ]
      },
      {
        "function_name": "AI::predictClick(Vector2<qreal> instant_vector, float *prediction_ref)",
        "params": "(Vector2<qreal> instant_vector, float *prediction_ref)",
        "body": "{\r\n     tiny_dnn::vec_t vec = {{normalize((float)instant_vector.x, game->getScreenWidth()), normalize((float)instant_vector.y, game->getScreenHeight()), birdSpeedY}};\r\n     float predicted = network.predict(vec)[0];\r\n\r\n     if(prediction_ref)\r\n        *prediction_ref = predicted;\r\n\r\n     return predicted >= clickThreshold ? true : false;\r\n}",
        "calls": [
          "normalize",
          "game->getScreenWidth",
          "normalize",
          "game->getScreenHeight",
          "network.predict"
        ]
      }
    ]
  },
  "Flappy-Bird-Qt\\source\\AI\\AI.h": {
    "includes": [
      "#include \"common.h\"\r\n",
      "#include \"tiny_dnn/tiny_dnn.h\"\r\n"
    ],
    "functions": []
  },
  "Flappy-Bird-Qt\\source\\Bird\\Bird.cpp": {
    "includes": [
      "#include \"Bird.h\"\r\n",
      "#include <QTimer>\r\n",
      "#include <QPropertyAnimation>\r\n"
    ],
    "functions": [
      {
        "function_name": "Bird::Bird(const QPointF& pos, const QPixmap& pixmap, const qreal &groundStartPosY, int scrWidth, int scrHeight, qreal scaleF)",
        "params": "(const QPointF& pos, const QPixmap& pixmap, const qreal &groundStartPosY, int scrWidth, int scrHeight, qreal scaleF)",
        "body": "{\r\n    setCacheMode(ItemCoordinateCache);\r\n\r\n    setPos(pos);\r\n\r\n    birdDesigner = new QTimer(this);\r\n    connect(birdDesigner, SIGNAL(timeout()), this, SLOT(designBird()));\r\n\r\n    rotator = new QPropertyAnimation(this, \"rotation\", this);\r\n    currentRotation = 0;\r\n\r\n    yAnimator = new QPropertyAnimation(this, \"y\", this);\r\n    connect(yAnimator, SIGNAL(finished()), this, SLOT(gravitation()));\r\n\r\n    oscillateDirection = 1;\r\n    oscillator = new QPropertyAnimation(this, \"pos\", this);\r\n    oscillator->setDuration(550);\r\n    oscillator->setEndValue(QPointF(boundingRect().width() * 2.75, y()));\r\n    oscillator->setEasingCurve(QEasingCurve::OutQuad);\r\n    connect(oscillator, SIGNAL(finished()), SLOT(oscillate()));\r\n\r\n    wingState = WingStates::up;\r\n    setColor(BirdTypes::yellow);\r\n\r\n    birdDesigner->start(75);\r\n}",
        "calls": [
          "setCacheMode",
          "setPos",
          "connect",
          "SIGNAL",
          "timeout",
          "SLOT",
          "designBird",
          "connect",
          "SIGNAL",
          "finished",
          "SLOT",
          "gravitation",
          "oscillator->setDuration",
          "oscillator->setEndValue",
          "QPointF",
          "boundingRect().width",
          "boundingRect",
          "y",
          "oscillator->setEasingCurve",
          "connect",
          "SIGNAL",
          "finished",
          "SLOT",
          "oscillate",
          "setColor",
          "birdDesigner->start"
        ]
      },
      {
        "function_name": "Bird::oscillate()",
        "params": "()",
        "body": "{\r\n    oscillator->setEasingCurve(QEasingCurve::OutCubic);\r\n\r\n    if(oscillateDirection)\r\n    {\r\n        oscillator->setEndValue(QPointF(x(), y() + PARAM_BIRD_OSCILLATE_FACTOR));\r\n        oscillateDirection = 0;\r\n    }\r\n    else\r\n    {\r\n        oscillator->setEndValue(QPointF(x(), y() - PARAM_BIRD_OSCILLATE_FACTOR));\r\n        oscillateDirection = 1;\r\n    }\r\n    startOscillate();\r\n}",
        "calls": [
          "oscillator->setEasingCurve",
          "oscillator->setEndValue",
          "QPointF",
          "x",
          "y",
          "oscillator->setEndValue",
          "QPointF",
          "x",
          "y",
          "startOscillate"
        ]
      },
      {
        "function_name": "Bird::designBird()",
        "params": "()",
        "body": "{\r\n    QPixmap design;\r\n\r\n    if(wingState == WingStates::middle)\r\n    {\r\n        if(wingDirection)\r\n        {\r\n            if(birdType == BirdTypes::red)\r\n                design.load(IMG_BIRD_RED_DOWN);\r\n            else if(birdType == BirdTypes::blue)\r\n                design.load(IMG_BIRD_BLUE_DOWN);\r\n            else\r\n                design.load(IMG_BIRD_YELLOW_DOWN);\r\n\r\n            setPixmap(design.scaled(design.size() * scaleFactor));\r\n            wingState = WingStates::down;\r\n            wingDirection = 0;\r\n        }\r\n        else\r\n        {\r\n            if(birdType == BirdTypes::red)\r\n                design.load(IMG_BIRD_RED_UP);\r\n            else if(birdType == BirdTypes::blue)\r\n                design.load(IMG_BIRD_BLUE_UP);\r\n            else\r\n                design.load(IMG_BIRD_YELLOW_UP);\r\n\r\n            setPixmap(design.scaled(design.size() * scaleFactor));\r\n            wingState = WingStates::up;\r\n            wingDirection = 1;\r\n        }\r\n    }\r\n    else\r\n    {\r\n        if(birdType == BirdTypes::red)\r\n            design.load(IMG_BIRD_RED_MIDDLE);\r\n        else if(birdType == BirdTypes::blue)\r\n            design.load(IMG_BIRD_BLUE_MIDDLE);\r\n        else\r\n            design.load(IMG_BIRD_YELLOW_MIDDLE);\r\n\r\n        setPixmap(design.scaled(design.size() * scaleFactor));\r\n        wingState = WingStates::middle;\r\n    }\r\n\r\n}",
        "calls": [
          "design.load",
          "design.load",
          "design.load",
          "setPixmap",
          "design.scaled",
          "design.size",
          "design.load",
          "design.load",
          "design.load",
          "setPixmap",
          "design.scaled",
          "design.size",
          "design.load",
          "design.load",
          "design.load",
          "setPixmap",
          "design.scaled",
          "design.size"
        ]
      },
      {
        "function_name": "Bird::setColor(BirdTypes type)",
        "params": "(BirdTypes type)",
        "body": "{\r\n    birdType = type;\r\n}",
        "calls": []
      },
      {
        "function_name": "Bird::gravitation()",
        "params": "()",
        "body": "{\r\n    birdDesigner->setInterval(85);\r\n\r\n    rotate(90, 675, QEasingCurve::InCubic);\r\n\r\n    qreal endPos = groundYPos;\r\n    qreal curPosY = y();\r\n\r\n    yAnimator->setStartValue(curPosY);\r\n    yAnimator->setEasingCurve(QEasingCurve::InQuad);\r\n    yAnimator->setEndValue(endPos);\r\n\r\n\r\n    if (abs(curPosY - endPos) < 0.01)\r\n    {\r\n        birdDesigner->stop();\r\n        yAnimator->stop();\r\n        rotator->stop();\r\n        return;\r\n    }\r\n\r\n    yAnimator->setDuration(800);\r\n\r\n    yAnimator->start();\r\n}",
        "calls": [
          "birdDesigner->setInterval",
          "rotate",
          "y",
          "yAnimator->setStartValue",
          "yAnimator->setEasingCurve",
          "yAnimator->setEndValue",
          "abs",
          "birdDesigner->stop",
          "yAnimator->stop",
          "rotator->stop",
          "yAnimator->setDuration",
          "yAnimator->start"
        ]
      },
      {
        "function_name": "Bird::fall()",
        "params": "()",
        "body": "{\r\n    yAnimator->stop();\r\n    gravitation();\r\n}",
        "calls": [
          "yAnimator->stop",
          "gravitation"
        ]
      },
      {
        "function_name": "Bird::rotate(const qreal &end, const int& duration, const QEasingCurve& curve)",
        "params": "(const qreal &end, const int& duration, const QEasingCurve& curve)",
        "body": "{\r\n    rotator->setDuration(duration);\r\n    rotator->setStartValue(currentRotation);\r\n    rotator->setEndValue(end);\r\n    rotator->setEasingCurve(curve);\r\n    rotator->start();\r\n}",
        "calls": [
          "rotator->setDuration",
          "rotator->setStartValue",
          "rotator->setEndValue",
          "rotator->setEasingCurve",
          "rotator->start"
        ]
      },
      {
        "function_name": "Bird::setRotation(qreal angle)",
        "params": "(qreal angle)",
        "body": "{\r\n       if (abs(currentRotation - angle) > 0.01)\r\n       {\r\n           currentRotation = angle;\r\n           QPointF c = boundingRect().center();\r\n           QTransform t;\r\n           t.translate(c.x(), c.y());\r\n           t.rotate(angle);\r\n           t.translate(-c.x(), -c.y());\r\n           setTransform(t);\r\n       }\r\n}",
        "calls": [
          "abs",
          "boundingRect().center",
          "boundingRect",
          "t.translate",
          "c.x",
          "c.y",
          "t.rotate",
          "t.translate",
          "c.x",
          "c.y",
          "setTransform"
        ]
      },
      {
        "function_name": "Bird::startOscillate()",
        "params": "()",
        "body": "{\r\n    birdDesigner->start(85);\r\n    oscillator->start();\r\n}",
        "calls": [
          "birdDesigner->start",
          "oscillator->start"
        ]
      },
      {
        "function_name": "Bird::stopOscillate()",
        "params": "()",
        "body": "{\r\n    oscillator->stop();\r\n}",
        "calls": [
          "oscillator->stop"
        ]
      },
      {
        "function_name": "Bird::rise()",
        "params": "()",
        "body": "{\r\n    qreal curPosY = y();\r\n    yAnimator->stop();\r\n    yAnimator->setStartValue(curPosY);\r\n    yAnimator->setEasingCurve(QEasingCurve::OutQuad);\r\n    yAnimator->setEndValue(curPosY - (screenHeight / 10));\r\n\r\n    yAnimator->setDuration(285);\r\n\r\n    yAnimator->start();\r\n\r\n    birdDesigner->setInterval(35);\r\n\r\n    rotate(-20, 95, QEasingCurve::OutQuad);\r\n}",
        "calls": [
          "y",
          "yAnimator->stop",
          "yAnimator->setStartValue",
          "yAnimator->setEasingCurve",
          "yAnimator->setEndValue",
          "yAnimator->setDuration",
          "yAnimator->start",
          "birdDesigner->setInterval",
          "rotate"
        ]
      }
    ]
  },
  "Flappy-Bird-Qt\\source\\Bird\\Bird.h": {
    "includes": [
      "#include \"common.h\"\r\n",
      "#include <QObject>\r\n",
      "#include <QGraphicsPixmapItem>\r\n"
    ],
    "functions": []
  },
  "Flappy-Bird-Qt\\source\\Button\\Button.cpp": {
    "includes": [
      "#include \"Button.h\"\r\n",
      "#include <QMessageBox>\r\n",
      "#include <QString>\r\n",
      "#include <QSound>\r\n",
      "#include \"Game/Game.h\"\r\n",
      "#include \"Scene/Scene.h\"\r\n",
      "#include \"Sound/Sound.h\"\r\n"
    ],
    "functions": [
      {
        "function_name": "ButtonFuncs::about(Game *game_instance)",
        "params": "(Game *game_instance)",
        "body": "{\r\n    QWidget *gameQObject = dynamic_cast<QWidget *>(game_instance);\r\n    QMessageBox::about(gameQObject, \"About...\", QString(\"Flappy Bird Qt by fuzun\\nVersion: v%1\\n\\ngithub.com/fuzun/Flappy-Bird-Qt\").arg(QCoreApplication::applicationVersion()));\r\n}",
        "calls": [
          "dynamic_cast<QWidget *>",
          "QMessageBox::about",
          "QString(\"Flappy Bird Qt by fuzun\\nVersion: v%1\\n\\ngithub.com/fuzun/Flappy-Bird-Qt\").arg",
          "QString",
          "QCoreApplication::applicationVersion"
        ]
      },
      {
        "function_name": "ButtonFuncs::play(Game *game_instance)",
        "params": "(Game *game_instance)",
        "body": "{\r\n    game_instance->sound_swooshing->playIfEnabled();\r\n\r\n    if(!game_instance->isGameFinished())\r\n    {\r\n         game_instance->prepareFirstGame();\r\n         game_instance->scene->fadeGroup(GROUP_FIRSTSCREEN, false, 500, GROUP_GAMEPLAY);\r\n    }\r\n    else\r\n    {\r\n        game_instance->prepareNewRound();\r\n    }\r\n}",
        "calls": [
          "game_instance->sound_swooshing->playIfEnabled",
          "game_instance->isGameFinished",
          "game_instance->prepareFirstGame",
          "game_instance->scene->fadeGroup",
          "game_instance->prepareNewRound"
        ]
      },
      {
        "function_name": "ButtonFuncs::soundDisable(Game *game_instance)",
        "params": "(Game *game_instance)",
        "body": "{\r\n    game_instance->soundDisable();\r\n}",
        "calls": [
          "game_instance->soundDisable"
        ]
      },
      {
        "function_name": "ButtonFuncs::soundEnable(Game *game_instance)",
        "params": "(Game *game_instance)",
        "body": "{\r\n    game_instance->soundEnable();\r\n}",
        "calls": [
          "game_instance->soundEnable"
        ]
      },
      {
        "function_name": "ButtonFuncs::aiEnable(Game *game_instance)",
        "params": "(Game *game_instance)",
        "body": "{\r\n    game_instance->AIEnable();\r\n    QApplication::processEvents();\r\n    ButtonFuncs::play(game_instance);\r\n}",
        "calls": [
          "game_instance->AIEnable",
          "QApplication::processEvents",
          "ButtonFuncs::play"
        ]
      },
      {
        "function_name": "ButtonFuncs::aiPlay(Game *game_instance)",
        "params": "(Game *game_instance)",
        "body": "{\r\n    game_instance->aiPlays = true;\r\n    ButtonFuncs::play(game_instance);\r\n}",
        "calls": [
          "ButtonFuncs::play"
        ]
      },
      {
        "function_name": "Button::invoke(Game *parent_game)",
        "params": "(Game *parent_game)",
        "body": "{\r\n    bool toggleStatus = (pixmap() == Pixmap);\r\n    if(parent_game == nullptr)\r\n        if(toggle && !toggleStatus)\r\n            buttonFunction2(game);\r\n        else\r\n            buttonFunction(game);\r\n    else\r\n        if(toggle && !toggleStatus)\r\n            buttonFunction2(parent_game);\r\n        else\r\n            buttonFunction(parent_game);\r\n\r\n    if(toggle)\r\n        setPixmap(toggleStatus ? Pixmap2 : Pixmap);\r\n}",
        "calls": [
          "pixmap",
          "buttonFunction2",
          "buttonFunction",
          "buttonFunction2",
          "buttonFunction",
          "setPixmap"
        ]
      }
    ]
  },
  "Flappy-Bird-Qt\\source\\Button\\Button.h": {
    "includes": [
      "#include \"common.h\"\r\n",
      "#include <QGraphicsPixmapItem>\r\n",
      "#include <QPixmap>\r\n"
    ],
    "functions": [
      {
        "function_name": "ButtonFuncs()",
        "params": "()",
        "body": "{}",
        "calls": []
      },
      {
        "function_name": "Button(Game *parent_game, const QPixmap& pixmap, Function function, bool toggleMode = false, const QPixmap& pixmap2 = QPixmap(), Function function2 = nullptr)",
        "params": "(Game *parent_game, const QPixmap& pixmap, Function function, bool toggleMode = false, const QPixmap& pixmap2 = QPixmap(), Function function2 = nullptr)",
        "body": "{}",
        "calls": []
      }
    ]
  },
  "Flappy-Bird-Qt\\source\\Game\\Game.cpp": {
    "includes": [
      "#include \"Game.h\"\r\n",
      "#include <QSound>\r\n",
      "#include <QTimer>\r\n",
      "#include <QImage>\r\n",
      "#include <QPainter>\r\n",
      "#include <QSettings>\r\n",
      "#include <QEasingCurve>\r\n",
      "#include <QTimer>\r\n",
      "#include \"MainWindow/MainWindow.h\"\r\n",
      "#include \"View/View.h\"\r\n",
      "#include \"Bird/Bird.h\"\r\n",
      "#include \"Button/Button.h\"\r\n",
      "#include \"Scene/Scene.h\"\r\n",
      "#include \"Physics/Physics.h\"\r\n",
      "#include \"Sound/Sound.h\"\r\n",
      "#include \"AI/AI.h\"\r\n"
    ],
    "functions": [
      {
        "function_name": "Game::Game(View *GraphicsView, QSettings *cfg, QSettings *settings, int windowWidth, int windowHeight)",
        "params": "(View *GraphicsView, QSettings *cfg, QSettings *settings, int windowWidth, int windowHeight)",
        "body": "{\r\n    scoreRecord = 0;\r\n    score = 0;\r\n\r\n    gameFinished = 0;\r\n    gameStarted = 0;\r\n    gameActuallyStarted = 0;\r\n\r\n    birdClosestPipe = 1;\r\n\r\n    aiPlays = false;\r\n    ai = nullptr;\r\n\r\n    scaleFactor = GAME_DEFAULT_SCALEFACTOR;\r\n    soundEnabled = GAME_DEFAULT_SOUND_ENABLED;\r\n\r\n    sound_die = new Sound(SND_DIE, this);\r\n    sound_hit = new Sound(SND_HIT, this);\r\n    sound_point = new Sound(SND_POINT, this);\r\n    sound_swooshing = new Sound(SND_SWOOSHING, this);\r\n    sound_wing = new Sound(SND_WING, this);\r\n\r\n    loadConfiguration();\r\n\r\n    scene = new Scene(this, QRectF(0, 0, screenWidth, screenHeight));\r\n\r\n    physics = new Physics(this, physicsTickRate, physicsComplexAnalysis, true, physicsSpeedFactor, physicsDisableCollisionDetection);\r\n}",
        "calls": [
          "loadConfiguration",
          "QRectF"
        ]
      },
      {
        "function_name": "Game::~Game()",
        "params": "()",
        "body": "{\r\n    AIDisable();\r\n    delete physics;\r\n    delete scene;\r\n\r\n    delete sound_die;\r\n    delete sound_hit;\r\n    delete sound_point;\r\n    delete sound_swooshing;\r\n    delete sound_wing;\r\n}",
        "calls": [
          "AIDisable"
        ]
      },
      {
        "function_name": "Game::loadConfiguration()",
        "params": "()",
        "body": "{\r\n    scaleFactor = config->value(CONFIG_SCALEFACTOR, scaleFactor).toReal();\r\n\r\n    soundEnabled = registry->value(CONFIG_SOUNDENABLED, soundEnabled).toBool();\r\n    scoreRecord = registry->value(CONFIG_SCORE_RECORD, 0).toInt();\r\n\r\n    // config->beginGroup(CONFIG_GENERAL);\r\n    soundEnabled = config->value(CONFIG_SOUNDENABLED, soundEnabled).toBool();\r\n    // config->endGroup();\r\n\r\n    config->beginGroup(CONFIG_PHYSICS);\r\n    physicsTickRate = config->value(CONFIG_PHYSICS_TICKRATE, PHYSICS_DEFAULT_TICKRATE).toInt();\r\n    physicsComplexAnalysis = config->value(CONFIG_PHYSICS_COMPLEXANALYSIS, PHYSICS_COMPLEXANALYSIS_ENABLED).toBool();\r\n    physicsSpeedFactor = config->value(CONFIG_PHYSICS_SPEEDFACTOR, PHYSICS_DEFAULT_SPEEDFACTOR).toReal();\r\n    physicsDisableCollisionDetection = config->value(CONFIG_PHYSICS_DISABLECOLLISIONDETECTION, PHYSICS_DEFAULT_DISABLECOLLISIONDETECTION).toBool();\r\n    config->endGroup();\r\n\r\n    config->beginGroup(CONFIG_AI);\r\n    aiNeuronCount = config->value(CONFIG_AI_NEURONCOUNT, AI_DEFAULT_NEURONCOUNT).toInt();\r\n    aiBatchSize = config->value(CONFIG_AI_BATCHSIZE, AI_DEFAULT_BATCHSIZE).toInt();\r\n    aiEpochs = config->value(CONFIG_AI_EPOCHS, AI_DEFAULT_EPOCHS).toInt();\r\n    aiUpdateInterval = config->value(CONFIG_AI_UPDATEINTERVAL, AI_DEFAULT_UPDATEINTERVAL).toInt();\r\n    aiClickThreshold = config->value(CONFIG_AI_CLICKTHRESHOLD, AI_DEFAULT_CLICKTHRESHOLD).toFloat();\r\n    config->endGroup();\r\n}",
        "calls": [
          "config->value(CONFIG_SCALEFACTOR, scaleFactor).toReal",
          "config->value",
          "registry->value(CONFIG_SOUNDENABLED, soundEnabled).toBool",
          "registry->value",
          "registry->value(CONFIG_SCORE_RECORD, 0).toInt",
          "registry->value",
          "config->value(CONFIG_SOUNDENABLED, soundEnabled).toBool",
          "config->value",
          "config->beginGroup",
          "config->value(CONFIG_PHYSICS_TICKRATE, PHYSICS_DEFAULT_TICKRATE).toInt",
          "config->value",
          "config->value(CONFIG_PHYSICS_COMPLEXANALYSIS, PHYSICS_COMPLEXANALYSIS_ENABLED).toBool",
          "config->value",
          "config->value(CONFIG_PHYSICS_SPEEDFACTOR, PHYSICS_DEFAULT_SPEEDFACTOR).toReal",
          "config->value",
          "config->value(CONFIG_PHYSICS_DISABLECOLLISIONDETECTION, PHYSICS_DEFAULT_DISABLECOLLISIONDETECTION).toBool",
          "config->value",
          "config->endGroup",
          "config->beginGroup",
          "config->value(CONFIG_AI_NEURONCOUNT, AI_DEFAULT_NEURONCOUNT).toInt",
          "config->value",
          "config->value(CONFIG_AI_BATCHSIZE, AI_DEFAULT_BATCHSIZE).toInt",
          "config->value",
          "config->value(CONFIG_AI_EPOCHS, AI_DEFAULT_EPOCHS).toInt",
          "config->value",
          "config->value(CONFIG_AI_UPDATEINTERVAL, AI_DEFAULT_UPDATEINTERVAL).toInt",
          "config->value",
          "config->value(CONFIG_AI_CLICKTHRESHOLD, AI_DEFAULT_CLICKTHRESHOLD).toFloat",
          "config->value",
          "config->endGroup"
        ]
      },
      {
        "function_name": "Game::getScore()",
        "params": "()",
        "body": "{\r\n    return score;\r\n}",
        "calls": []
      },
      {
        "function_name": "Game::getScoreRecord()",
        "params": "()",
        "body": "{\r\n    return scoreRecord;\r\n}",
        "calls": []
      },
      {
        "function_name": "Game::getScreenHeight()",
        "params": "()",
        "body": "{\r\n    return screenHeight;\r\n}",
        "calls": []
      },
      {
        "function_name": "Game::getScreenWidth()",
        "params": "()",
        "body": "{\r\n    return screenWidth;\r\n}",
        "calls": []
      },
      {
        "function_name": "Game::getScaleFactor()",
        "params": "()",
        "body": "{\r\n    return scaleFactor;\r\n}",
        "calls": []
      },
      {
        "function_name": "Game::clickEvent()",
        "params": "()",
        "body": "{\r\n    if(gameActuallyStarted)\r\n    {\r\n        if(!isGameStarted())\r\n        {\r\n            scene->bird->stopOscillate();\r\n\r\n            scene->fadeGroup(GROUP_NEWROUND, false, 100);\r\n\r\n            if(physics)\r\n                physics->switchOnlyGroundMove();\r\n\r\n            gameStarted = true;\r\n        }\r\n        else\r\n        {\r\n#ifndef AI_DISABLED\r\n        if(ai)\r\n            ai->birdTriggered();\r\n#endif\r\n        }\r\n\r\n        if(scene->isGroupVisible(GROUP_NEWROUND))\r\n            scene->fadeGroup(GROUP_NEWROUND, false, 5);\r\n\r\n        scene->bird->rise();\r\n\r\n        sound_wing->playIfEnabled();\r\n\r\n        return;\r\n    }\r\n}",
        "calls": [
          "isGameStarted",
          "scene->bird->stopOscillate",
          "scene->fadeGroup",
          "physics->switchOnlyGroundMove",
          "ai->birdTriggered",
          "scene->isGroupVisible",
          "scene->fadeGroup",
          "scene->bird->rise",
          "sound_wing->playIfEnabled"
        ]
      },
      {
        "function_name": "Game::isSoundEnabled()",
        "params": "()",
        "body": "{\r\n    return soundEnabled;\r\n}",
        "calls": []
      },
      {
        "function_name": "Game::soundDisable()",
        "params": "()",
        "body": "{\r\n    soundEnabled = false;\r\n    registry->setValue(CONFIG_SOUNDENABLED, soundEnabled);\r\n}",
        "calls": [
          "registry->setValue"
        ]
      },
      {
        "function_name": "Game::soundEnable()",
        "params": "()",
        "body": "{\r\n    soundEnabled = true;\r\n    registry->setValue(CONFIG_SOUNDENABLED, soundEnabled);\r\n}",
        "calls": [
          "registry->setValue"
        ]
      },
      {
        "function_name": "Game::isAIEnabled()",
        "params": "()",
        "body": "{\r\n    if(ai == nullptr)\r\n        return false;\r\n    else\r\n        return true;\r\n}",
        "calls": []
      },
      {
        "function_name": "Game::AIEnable()",
        "params": "()",
        "body": "{\r\n#ifndef AI_DISABLED\r\n    if(!isAIEnabled())\r\n    {\r\n\r\n        ai = new AI(this, aiNeuronCount, aiBatchSize, aiEpochs, aiUpdateInterval, aiClickThreshold);\r\n\r\n        for(int k = 0; k < GROUP_MAX_ITEM_COUNT; k++) // This method should change in future!\r\n        {\r\n            if(scene->group_item[GROUP_ROUNDEND][k] == nullptr)\r\n            {\r\n                scene->group_item[GROUP_ROUNDEND][k] = scene->item_button_AIPlay;\r\n                scene->group_item[GROUP_ROUNDEND][k + 1] = nullptr;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n#endif\r\n}",
        "calls": [
          "isAIEnabled"
        ]
      },
      {
        "function_name": "Game::AIDisable()",
        "params": "()",
        "body": "{\r\n#ifndef AI_DISABLED\r\n    if(isAIEnabled())\r\n    {\r\n        delete ai;\r\n        ai = nullptr;\r\n    }\r\n#endif\r\n}",
        "calls": [
          "isAIEnabled"
        ]
      },
      {
        "function_name": "Game::prepareNewRound()",
        "params": "()",
        "body": "{\r\n    scene->flash(Qt::black, 500, QEasingCurve::Linear);\r\n\r\n    QTimer::singleShot(550, [this]() {\r\n#ifndef AI_DISABLED\r\n             if(ai)\r\n             {\r\n                if(!ai->trainingFinished)\r\n                    ai->stopTrain();\r\n                ai->clearData();\r\n             }\r\n#endif\r\n\r\n             int random1 = Physics::randInt(0, 2);\r\n             int random2 = Physics::randInt(0, 1);\r\n\r\n             if(random1 == 0)\r\n                 scene->bird->setColor(Bird::BirdTypes::yellow);\r\n             else if(random1 == 1)\r\n                 scene->bird->setColor(Bird::BirdTypes::blue);\r\n             else // == 2\r\n                 scene->bird->setColor(Bird::BirdTypes::red);\r\n\r\n             if(random2 == 0)\r\n             {\r\n                  graphicsView->setBackgroundBrush(QBrush(QPixmap(IMG_BACKGROUND_DAY).scaled(screenWidth,screenHeight)));\r\n             }\r\n             else // == 1\r\n             {\r\n                  graphicsView->setBackgroundBrush(QBrush(QPixmap(IMG_BACKGROUND_NIGHT).scaled(screenWidth,screenHeight)));\r\n             }\r\n\r\n             scene->fadeGroup(GROUP_NEWROUND, true, 1, GROUP_ROUNDEND);\r\n\r\n\r\n             delete physics;\r\n             physics = new Physics(this, physicsTickRate, physicsComplexAnalysis, false, physicsSpeedFactor, physicsDisableCollisionDetection);\r\n\r\n             score = -1;\r\n             updateScore();\r\n\r\n             gameStarted = false;\r\n\r\n             scene->bird->setPos(scene->bird->boundingRect().width() * 2.75, POS_Y_LOGO(screenHeight) + QPixmap(IMG_BIRD_YELLOW_UP).height() * 5);\r\n\r\n             prepareFirstGame();\r\n\r\n             scene->bird->setRotation(0);\r\n\r\n             physics->start();\r\n             physics->switchOnlyGroundMove();\r\n    });\r\n}",
        "calls": [
          "scene->flash",
          "QTimer::singleShot",
          "ai->stopTrain",
          "ai->clearData",
          "Physics::randInt",
          "Physics::randInt",
          "scene->bird->setColor",
          "scene->bird->setColor",
          "scene->bird->setColor",
          "graphicsView->setBackgroundBrush",
          "QBrush",
          "QPixmap(IMG_BACKGROUND_DAY).scaled",
          "QPixmap",
          "graphicsView->setBackgroundBrush",
          "QBrush",
          "QPixmap(IMG_BACKGROUND_NIGHT).scaled",
          "QPixmap",
          "scene->fadeGroup",
          "updateScore",
          "scene->bird->setPos",
          "scene->bird->boundingRect().width",
          "scene->bird->boundingRect",
          "POS_Y_LOGO",
          "QPixmap(IMG_BIRD_YELLOW_UP).height",
          "QPixmap",
          "prepareFirstGame",
          "scene->bird->setRotation",
          "physics->start",
          "physics->switchOnlyGroundMove"
        ]
      },
      {
        "function_name": "Game::prepareFirstGame()",
        "params": "()",
        "body": "{\r\n    scene->bird->startOscillate();\r\n\r\n    gameFinished = false;\r\n    gameActuallyStarted = true;\r\n}",
        "calls": [
          "scene->bird->startOscillate"
        ]
      },
      {
        "function_name": "Game::gameOver()",
        "params": "()",
        "body": "{\r\n    physics->stop();\r\n\r\n    if(score > scoreRecord)\r\n    {\r\n        registry->setValue(CONFIG_SCORE_RECORD, score);\r\n        scoreRecord = score;\r\n    }\r\n\r\n    if(soundEnabled)\r\n    {\r\n        sound_die->playIfEnabled();\r\n        sound_hit->playIfEnabled();\r\n    }\r\n\r\n    scene->gameOver(score, scoreRecord);\r\n\r\n    gameFinished = true;\r\n    gameActuallyStarted = false;\r\n    birdClosestPipe = 1;\r\n\r\n#ifndef AI_DISABLED\r\n    if(ai)\r\n    {\r\n        aiPlays = false;\r\n        QTimer::singleShot(500, [this]() {\r\n            ai->train();\r\n        });\r\n    }\r\n#endif\r\n}",
        "calls": [
          "physics->stop",
          "registry->setValue",
          "sound_die->playIfEnabled",
          "sound_hit->playIfEnabled",
          "scene->gameOver",
          "QTimer::singleShot",
          "ai->train"
        ]
      },
      {
        "function_name": "Game::isGameFinished()",
        "params": "()",
        "body": "{\r\n    return gameFinished;\r\n}",
        "calls": []
      },
      {
        "function_name": "Game::isGameStarted()",
        "params": "()",
        "body": "{\r\n    return gameStarted;\r\n}",
        "calls": []
      },
      {
        "function_name": "Game::isGameActuallyStarted()",
        "params": "()",
        "body": "{\r\n    return gameActuallyStarted;\r\n}",
        "calls": []
      },
      {
        "function_name": "Game::updateScore()",
        "params": "()",
        "body": "{\r\n    if(score != -1)\r\n        sound_point->playIfEnabled();\r\n\r\n    ++score;\r\n\r\n    scene->updateScore(score);\r\n}",
        "calls": [
          "sound_point->playIfEnabled",
          "scene->updateScore"
        ]
      }
    ]
  },
  "Flappy-Bird-Qt\\source\\Game\\Game.h": {
    "includes": [
      "#include \"common.h\"\r\n"
    ],
    "functions": []
  },
  "Flappy-Bird-Qt\\source\\MainWindow\\MainWindow.cpp": {
    "includes": [
      "#include \"MainWindow.h\"\r\n",
      "#include <QDesktopWidget>\r\n",
      "#include <QSettings>\r\n",
      "#include <QGraphicsView>\r\n",
      "#include <QResizeEvent>\r\n",
      "#include <QTimer>\r\n",
      "#include <QScreen>\r\n",
      "#include <QtOpenGL>\r\n",
      "#include \"View/View.h\"\r\n",
      "#include \"Game/Game.h\"\r\n",
      "#include \"strobe-api/strobe/strobe-core.h\"\r\n",
      "#include \"StrobeDialog/StrobeDialog.h\"\r\n"
    ],
    "functions": [
      {
        "function_name": "MainWindow::MainWindow(QWidget *parent)",
        "params": "(QWidget *parent)",
        "body": "{\r\n    config = new QSettings(QApplication::applicationDirPath() + \"/\" + CONFIG_FILENAME, QSettings::IniFormat, this);\r\n\r\n    bool strobeEnabled;\r\n\r\n#ifndef STROBE_DISABLED\r\n    config->beginGroup(CONFIG_STROBE);\r\n    strobeEnabled = config->value(CONFIG_STROBE_ENABLED, STROBE_ENABLED).toBool();\r\n    int strobeMode = config->value(CONFIG_STROBE_MODE, STROBE_DEFAULT_MODE).toInt();\r\n    int strobeDialogUpdateInterval = config->value(CONFIG_STROBE_DIALOG_UPDATEINTERVAL, STROBE_DEFAULT_DIALOG_UPDATEINTERVAL).toInt();\r\n    bool strobeDialogEnabled = config->value(CONFIG_STROBE_DIALOG_ENABLED, STROBE_DEFAULT_DIALOG_ENABLED).toBool();\r\n    int strobeSwitchInterval = config->value(CONFIG_STROBE_SWITCHINTERVAL, STROBE_DEFAULT_SWITCHINTERVAL).toInt();\r\n    config->endGroup();\r\n\r\n    if(strobeEnabled || strobeMode == 0)\r\n        strobe = new StrobeCore(strobeMode, strobeSwitchInterval);\r\n    else\r\n        strobe = nullptr;\r\n#else\r\n    strobe = nullptr;\r\n    strobeEnabled = false;\r\n#endif\r\n\r\n    settings = new QSettings(QApplication::organizationName(), QApplication::applicationName(), this);\r\n\r\n    graphicsView = new View(this, strobe);\r\n\r\n    graphicsView->setFixedSize(settings->value(CONFIG_SCREENWIDTH, GAME_DEFAULT_SCREENWIDTH).toInt(), settings->value(CONFIG_SCREENHEIGHT, GAME_DEFAULT_SCREENHEIGHT).toInt());\r\n\r\n    // config->beginGroup(CONFIG_GENERAL);\r\n    if(config->value(CONFIG_FULLSCREEN, 0).toBool())\r\n    {\r\n        screenHeight = QGuiApplication::primaryScreen()->availableSize().height();\r\n        screenWidth = QGuiApplication::primaryScreen()->availableSize().width();\r\n        QTimer::singleShot(500, this, SLOT(showFullScreen()));\r\n    }\r\n    else\r\n    {\r\n        graphicsView->setFixedSize(config->value(CONFIG_SCREENWIDTH, GAME_DEFAULT_SCREENWIDTH).toInt(), config->value(CONFIG_SCREENHEIGHT, GAME_DEFAULT_SCREENHEIGHT).toInt());\r\n        screenHeight = graphicsView->height();\r\n        screenWidth = graphicsView->width();\r\n    }\r\n    // config->endGroup();\r\n\r\n    config->beginGroup(CONFIG_GRAPHICS);\r\n\r\n    bool gpuRender = config->value(CONFIG_OPENGL, GAME_DEFAULT_OPENGL_ENABLED).toBool();\r\n    if(gpuRender)\r\n    {\r\n        QOpenGLWidget *glWidget = new QOpenGLWidget(this);\r\n        graphicsView->setViewport(glWidget);\r\n\r\n        if(strobeEnabled)\r\n        {\r\n            prepareManualViewportUpdate();\r\n        }\r\n        else\r\n        {\r\n            graphicsView->setViewportUpdateMode(QGraphicsView::FullViewportUpdate);\r\n        }\r\n    }\r\n    else\r\n    {\r\n        bool fpsCap = config->value(CONFIG_FPSCAP, GAME_DEFAULT_FPSCAP).toBool();\r\n        int _config_viewportupdate = config->value(CONFIG_VIEWPORTUPDATE, GAME_DEFAULT_VIEWPORTUPDATE).toInt();\r\n\r\n        if(fpsCap)\r\n        {\r\n            if(_config_viewportupdate == 0)\r\n            {\r\n                graphicsView->setViewportUpdateMode(QGraphicsView::FullViewportUpdate);\r\n            }\r\n            else if(_config_viewportupdate == 1)\r\n            {\r\n                graphicsView->setViewportUpdateMode(QGraphicsView::MinimalViewportUpdate);\r\n            }\r\n            else\r\n            {\r\n                graphicsView->setViewportUpdateMode(QGraphicsView::SmartViewportUpdate);\r\n            }\r\n        }\r\n        else\r\n        {\r\n            prepareManualViewportUpdate();\r\n        }\r\n\r\n#ifndef STROBE_DISABLED\r\n        if(strobeEnabled)\r\n        {\r\n            strobe->setMode(0);\r\n            strobe->disable();\r\n        }\r\n#endif\r\n    }\r\n\r\n    if(config->value(CONFIG_ANTIALIASING, GAME_DEFAULT_ANTIALIASING_ENABLED).toBool())\r\n        graphicsView->setRenderHint(QPainter::Antialiasing);\r\n    else\r\n        graphicsView->setRenderHint(QPainter::Antialiasing, 0);\r\n    if(config->value(CONFIG_SMOOTHPIXMAPTRANSFORM, GAME_DEFAULT_SMOOTHPIXMAPTRANSFORM_ENABLED).toBool())\r\n        graphicsView->setRenderHint(QPainter::SmoothPixmapTransform);\r\n    else\r\n        graphicsView->setRenderHint(QPainter::SmoothPixmapTransform, 0);\r\n    if(config->value(CONFIG_HQANTIALIASING, GAME_DEFAULT_HQANTIALIASING_ENABLED).toBool())\r\n        graphicsView->setRenderHint(QPainter::HighQualityAntialiasing);\r\n    else\r\n        graphicsView->setRenderHint(QPainter::HighQualityAntialiasing, 0);\r\n\r\n    config->endGroup();\r\n\r\n    graphicsView->setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOff);\r\n    graphicsView->setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOff);\r\n\r\n    setCentralWidget(graphicsView);\r\n    adjustSize();\r\n\r\n    game = new Game(graphicsView, config, settings, screenWidth, screenHeight);\r\n\r\n#ifndef STROBE_DISABLED\r\n    if(strobeDialogEnabled && (strobe != nullptr))\r\n    {\r\n        strobeDialog = new StrobeDialog(strobe, this, x() + width() + 20, y(), strobeDialogUpdateInterval);\r\n    }\r\n    else\r\n    {\r\n        strobeDialog = nullptr;\r\n    }\r\n#endif\r\n\r\n    resizer = new QTimer(this);\r\n    connect(resizer, SIGNAL(timeout()), this, SLOT(resizeTriggered()));\r\n}",
        "calls": [
          "QApplication::applicationDirPath",
          "config->beginGroup",
          "config->value(CONFIG_STROBE_ENABLED, STROBE_ENABLED).toBool",
          "config->value",
          "config->value(CONFIG_STROBE_MODE, STROBE_DEFAULT_MODE).toInt",
          "config->value",
          "config->value(CONFIG_STROBE_DIALOG_UPDATEINTERVAL, STROBE_DEFAULT_DIALOG_UPDATEINTERVAL).toInt",
          "config->value",
          "config->value(CONFIG_STROBE_DIALOG_ENABLED, STROBE_DEFAULT_DIALOG_ENABLED).toBool",
          "config->value",
          "config->value(CONFIG_STROBE_SWITCHINTERVAL, STROBE_DEFAULT_SWITCHINTERVAL).toInt",
          "config->value",
          "config->endGroup",
          "QApplication::organizationName",
          "QApplication::applicationName",
          "graphicsView->setFixedSize",
          "settings->value(CONFIG_SCREENWIDTH, GAME_DEFAULT_SCREENWIDTH).toInt",
          "settings->value",
          "settings->value(CONFIG_SCREENHEIGHT, GAME_DEFAULT_SCREENHEIGHT).toInt",
          "settings->value",
          "config->value(CONFIG_FULLSCREEN, 0).toBool",
          "config->value",
          "QGuiApplication::primaryScreen()->availableSize().height",
          "QGuiApplication::primaryScreen()->availableSize",
          "QGuiApplication::primaryScreen",
          "QGuiApplication::primaryScreen()->availableSize().width",
          "QGuiApplication::primaryScreen()->availableSize",
          "QGuiApplication::primaryScreen",
          "QTimer::singleShot",
          "SLOT",
          "showFullScreen",
          "graphicsView->setFixedSize",
          "config->value(CONFIG_SCREENWIDTH, GAME_DEFAULT_SCREENWIDTH).toInt",
          "config->value",
          "config->value(CONFIG_SCREENHEIGHT, GAME_DEFAULT_SCREENHEIGHT).toInt",
          "config->value",
          "graphicsView->height",
          "graphicsView->width",
          "config->beginGroup",
          "config->value(CONFIG_OPENGL, GAME_DEFAULT_OPENGL_ENABLED).toBool",
          "config->value",
          "graphicsView->setViewport",
          "prepareManualViewportUpdate",
          "graphicsView->setViewportUpdateMode",
          "config->value(CONFIG_FPSCAP, GAME_DEFAULT_FPSCAP).toBool",
          "config->value",
          "config->value(CONFIG_VIEWPORTUPDATE, GAME_DEFAULT_VIEWPORTUPDATE).toInt",
          "config->value",
          "graphicsView->setViewportUpdateMode",
          "graphicsView->setViewportUpdateMode",
          "graphicsView->setViewportUpdateMode",
          "prepareManualViewportUpdate",
          "strobe->setMode",
          "strobe->disable",
          "config->value(CONFIG_ANTIALIASING, GAME_DEFAULT_ANTIALIASING_ENABLED).toBool",
          "config->value",
          "graphicsView->setRenderHint",
          "graphicsView->setRenderHint",
          "config->value(CONFIG_SMOOTHPIXMAPTRANSFORM, GAME_DEFAULT_SMOOTHPIXMAPTRANSFORM_ENABLED).toBool",
          "config->value",
          "graphicsView->setRenderHint",
          "graphicsView->setRenderHint",
          "config->value(CONFIG_HQANTIALIASING, GAME_DEFAULT_HQANTIALIASING_ENABLED).toBool",
          "config->value",
          "graphicsView->setRenderHint",
          "graphicsView->setRenderHint",
          "config->endGroup",
          "graphicsView->setHorizontalScrollBarPolicy",
          "graphicsView->setVerticalScrollBarPolicy",
          "setCentralWidget",
          "adjustSize",
          "x",
          "width",
          "y",
          "connect",
          "SIGNAL",
          "timeout",
          "SLOT",
          "resizeTriggered"
        ]
      },
      {
        "function_name": "MainWindow::~MainWindow()",
        "params": "()",
        "body": "{\r\n    settings->setValue(CONFIG_SCREENWIDTH, width());\r\n    settings->setValue(CONFIG_SCREENHEIGHT, height());\r\n    settings->sync();\r\n\r\n    delete game;\r\n\r\n#ifndef STROBE_DISABLED\r\n    if(strobe != nullptr)\r\n        delete strobe;\r\n#endif\r\n}",
        "calls": [
          "settings->setValue",
          "width",
          "settings->setValue",
          "height",
          "settings->sync"
        ]
      },
      {
        "function_name": "MainWindow::prepareManualViewportUpdate()",
        "params": "()",
        "body": "{\r\n    graphicsView->setViewportUpdateMode(QGraphicsView::NoViewportUpdate);\r\n\r\n    QTimer *renderTimer = new QTimer(this);\r\n    renderTimer->setInterval(0);\r\n\r\n    connect(renderTimer, &QTimer::timeout, [this]() {\r\n        // QApplication::processEvents();\r\n        graphicsView->viewport()->update();\r\n    });\r\n    renderTimer->start();\r\n}",
        "calls": [
          "graphicsView->setViewportUpdateMode",
          "renderTimer->setInterval",
          "connect",
          "graphicsView->viewport()->update",
          "graphicsView->viewport",
          "renderTimer->start"
        ]
      },
      {
        "function_name": "MainWindow::resizeEvent(QResizeEvent *event)",
        "params": "(QResizeEvent *event)",
        "body": "{\r\n    QMainWindow::resizeEvent(event);\r\n\r\n    if(!resizer->isActive())\r\n        resizer->start(100);\r\n    resized = true;\r\n}",
        "calls": [
          "QMainWindow::resizeEvent",
          "resizer->isActive",
          "resizer->start"
        ]
      },
      {
        "function_name": "MainWindow::moveEvent(QMoveEvent *event)",
        "params": "(QMoveEvent *event)",
        "body": "{\r\n    QMainWindow::moveEvent(event);\r\n\r\n#ifndef STROBE_DISABLED\r\n    if(strobeDialog != nullptr)\r\n        strobeDialog->setPos(x() + width() + 20, y());\r\n#endif\r\n}",
        "calls": [
          "QMainWindow::moveEvent",
          "strobeDialog->setPos",
          "x",
          "width",
          "y"
        ]
      },
      {
        "function_name": "MainWindow::resizeTriggered()",
        "params": "()",
        "body": "{\r\n    if(!resized)\r\n    {\r\n        delete game;\r\n\r\n        int newWidth = width();\r\n        int newHeight = height();\r\n\r\n        graphicsView->setFixedSize(newWidth, newHeight);\r\n        adjustSize();\r\n        graphicsView->setMinimumSize(GAME_DEFAULT_SCREENWIDTH, GAME_DEFAULT_SCREENHEIGHT);\r\n\r\n#ifndef STROBE_DISABLED\r\n         if(strobeDialog != nullptr)\r\n         {\r\n            int availableWidth = QGuiApplication::primaryScreen()->availableSize().width();\r\n            int availableHeight = QGuiApplication::primaryScreen()->availableSize().height();\r\n\r\n            if((availableHeight - newHeight < 100) && (availableWidth - newWidth < 100))\r\n                strobeDialog->setPos(availableWidth - strobeDialog->width() - 20, availableHeight - strobeDialog->height() - 20);\r\n            else\r\n                strobeDialog->setPos(x() + newWidth + 20, y());\r\n         }\r\n#endif\r\n        game = new Game(graphicsView, config, settings, newWidth, newHeight);\r\n        resizer->stop();\r\n    }\r\n\r\n    resized = false;\r\n}",
        "calls": [
          "width",
          "height",
          "graphicsView->setFixedSize",
          "adjustSize",
          "graphicsView->setMinimumSize",
          "QGuiApplication::primaryScreen()->availableSize().width",
          "QGuiApplication::primaryScreen()->availableSize",
          "QGuiApplication::primaryScreen",
          "QGuiApplication::primaryScreen()->availableSize().height",
          "QGuiApplication::primaryScreen()->availableSize",
          "QGuiApplication::primaryScreen",
          "strobeDialog->setPos",
          "strobeDialog->width",
          "strobeDialog->height",
          "strobeDialog->setPos",
          "x",
          "y",
          "resizer->stop"
        ]
      }
    ]
  },
  "Flappy-Bird-Qt\\source\\MainWindow\\MainWindow.h": {
    "includes": [
      "#include \"common.h\"\r\n",
      "#include <QMainWindow>\r\n"
    ],
    "functions": []
  },
  "Flappy-Bird-Qt\\source\\Physics\\Physics.cpp": {
    "includes": [
      "#include \"Physics.h\"\r\n",
      "#include <QMainWindow>\r\n",
      "#include <QGraphicsScene>\r\n",
      "#include <QTimer>\r\n",
      "#include <QTransform>\r\n",
      "#include \"Game/Game.h\"\r\n",
      "#include \"View/View.h\"\r\n",
      "#include \"Bird/Bird.h\"\r\n",
      "#include \"Scene/Scene.h\"\r\n"
    ],
    "functions": [
      {
        "function_name": "Physics::Physics(Game *parent_game, int tickRate, bool complexAnalyse, bool isOnlyGround, qreal speedFactor, bool isCollisionDetectionDisabled)",
        "params": "(Game *parent_game, int tickRate, bool complexAnalyse, bool isOnlyGround, qreal speedFactor, bool isCollisionDetectionDisabled)",
        "body": "{\r\n    _transform = new QTransform();\r\n\r\n    bird = game->scene->bird;\r\n\r\n    pipeCriticX = pipeCriticXFinder(*(game->scene->pipe[0][0]));\r\n\r\n    pipeMarkers[0] = 0;\r\n    pipeMarkers[1] = 0;\r\n    pipeMarkers[2] = 0;\r\n    pipeMarkers[3] = 0;\r\n\r\n\r\n    markers[0] = 0;\r\n    markers[1] = 0;\r\n    markers[2] = 0;\r\n\r\n\r\n    game->scene->pipe[0][0]->setPos(game->getScreenWidth(), 0);\r\n    game->scene->pipe[0][1]->setPos(game->getScreenWidth(), 0);\r\n    game->scene->pipe[0][2]->setPos(game->getScreenWidth(), 0);\r\n    game->scene->pipe[1][0]->setPos(game->getScreenWidth(), 0);\r\n    game->scene->pipe[1][1]->setPos(game->getScreenWidth(), 0);\r\n    game->scene->pipe[1][2]->setPos(game->getScreenWidth(), 0);\r\n\r\n    physicsTimer = new QTimer();\r\n\r\n    QObject::connect(physicsTimer, &QTimer::timeout, [this](){\r\n        if(!onlyGround)\r\n        {\r\n            if(collisionCheck())\r\n            {\r\n                bird->fall();\r\n                game->gameOver();\r\n                return;\r\n            }\r\n            movePipes();\r\n        }\r\n        moveGround();\r\n        QApplication::processEvents();\r\n    });\r\n\r\n    physicsTimer->setInterval(onlyGround ? updateInterval * PHYSICS_ONLYGROUND_SLOW_RATE : updateInterval);\r\n    physicsTimer->start();\r\n}",
        "calls": [
          "pipeCriticXFinder",
          "game->scene->pipe[0][0]->setPos",
          "game->getScreenWidth",
          "game->scene->pipe[0][1]->setPos",
          "game->getScreenWidth",
          "game->scene->pipe[0][2]->setPos",
          "game->getScreenWidth",
          "game->scene->pipe[1][0]->setPos",
          "game->getScreenWidth",
          "game->scene->pipe[1][1]->setPos",
          "game->getScreenWidth",
          "game->scene->pipe[1][2]->setPos",
          "game->getScreenWidth",
          "QObject::connect",
          "collisionCheck",
          "bird->fall",
          "game->gameOver",
          "movePipes",
          "moveGround",
          "QApplication::processEvents",
          "physicsTimer->setInterval",
          "physicsTimer->start"
        ]
      },
      {
        "function_name": "Physics::~Physics()",
        "params": "()",
        "body": "{\r\n    delete _transform;\r\n    delete physicsTimer;\r\n}",
        "calls": []
      },
      {
        "function_name": "Physics::stop()",
        "params": "()",
        "body": "{\r\n    physicsTimer->stop();\r\n}",
        "calls": [
          "physicsTimer->stop"
        ]
      },
      {
        "function_name": "Physics::start()",
        "params": "()",
        "body": "{\r\n    physicsTimer->start();\r\n}",
        "calls": [
          "physicsTimer->start"
        ]
      },
      {
        "function_name": "Physics::moveGround()",
        "params": "()",
        "body": "{\r\n    game->scene->updateGround();\r\n    game->scene->ground->setPos(game->scene->ground->pos().x() - (PHYSICS_UNIT_MOVE_RATE(game->getScreenWidth()) * speedfactor), game->scene->ground->pos().y());\r\n}",
        "calls": [
          "game->scene->updateGround",
          "game->scene->ground->setPos",
          "game->scene->ground->pos().x",
          "game->scene->ground->pos",
          "PHYSICS_UNIT_MOVE_RATE",
          "game->getScreenWidth",
          "game->scene->ground->pos().y",
          "game->scene->ground->pos"
        ]
      },
      {
        "function_name": "Physics::pipeCriticXFinder(const QGraphicsPixmapItem& item_pipe)",
        "params": "(const QGraphicsPixmapItem& item_pipe)",
        "body": "{\r\n    int xVal = 0;\r\n    QImage refPipe = item_pipe.pixmap().toImage();\r\n\r\n    while(refPipe.pixel(xVal, refPipe.height() / 2) == 0)\r\n    {\r\n        ++xVal;\r\n    }\r\n    ++xVal;\r\n\r\n    return xVal;\r\n}",
        "calls": [
          "item_pipe.pixmap().toImage",
          "item_pipe.pixmap",
          "refPipe.pixel",
          "refPipe.height"
        ]
      },
      {
        "function_name": "Physics::isOnlyGround()",
        "params": "()",
        "body": "{\r\n    return onlyGround;\r\n}",
        "calls": []
      },
      {
        "function_name": "Physics::collisionCheckComplex(const QGraphicsPixmapItem& item_pipe)",
        "params": "(const QGraphicsPixmapItem& item_pipe)",
        "body": "{\r\n    _itemPipe.x = item_pipe.x();\r\n    _itemPipe.y = item_pipe.y();\r\n    _itemPipe.width = item_pipe.pixmap().width();\r\n    _itemPipe.height = item_pipe.pixmap().height();\r\n\r\n    *_transform = (game->graphicsView->transform());\r\n\r\n    if((bird->x() > _itemPipe.x) && (bird->x() < _itemPipe.x + _itemPipe.width))\r\n    {\r\n        for(qreal b = 0; b <= (_itemPipe.width); ++b)\r\n        {\r\n            if(((game->scene->itemAt(_itemPipe.x + b, _itemPipe.y, *_transform) == bird) ||\r\n                (game->scene->itemAt(_itemPipe.x + b, _itemPipe.y + _itemPipe.height, *_transform))) &&\r\n                    ((bird->pixmap().toImage().pixel(bird->mapFromScene(_itemPipe.x + b, _itemPipe.y).toPoint()) != 0) ||\r\n                     (bird->pixmap().toImage().pixel(bird->mapFromScene(_itemPipe.x + b, _itemPipe.y + _itemPipe.height).toPoint()) != 0)))\r\n            {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n\r\n    for(qreal a = 0; a <= (_itemPipe.height); ++a)\r\n    {\r\n        if((game->scene->itemAt(_itemPipe.x + pipeCriticX, _itemPipe.y + a, *_transform) == bird) &&\r\n                (bird->pixmap().toImage().pixel(bird->mapFromScene(_itemPipe.x + pipeCriticX, _itemPipe.y + a).toPoint()) != 0))\r\n        {\r\n            return true;\r\n        }\r\n    }\r\n\r\n    return false;\r\n}",
        "calls": [
          "item_pipe.x",
          "item_pipe.y",
          "item_pipe.pixmap().width",
          "item_pipe.pixmap",
          "item_pipe.pixmap().height",
          "item_pipe.pixmap",
          "game->graphicsView->transform",
          "bird->x",
          "bird->x",
          "game->scene->itemAt",
          "game->scene->itemAt",
          "bird->pixmap().toImage().pixel",
          "bird->pixmap().toImage",
          "bird->pixmap",
          "bird->mapFromScene(_itemPipe.x + b, _itemPipe.y).toPoint",
          "bird->mapFromScene",
          "bird->pixmap().toImage().pixel",
          "bird->pixmap().toImage",
          "bird->pixmap",
          "bird->mapFromScene(_itemPipe.x + b, _itemPipe.y + _itemPipe.height).toPoint",
          "bird->mapFromScene",
          "game->scene->itemAt",
          "bird->pixmap().toImage().pixel",
          "bird->pixmap().toImage",
          "bird->pixmap",
          "bird->mapFromScene(_itemPipe.x + pipeCriticX, _itemPipe.y + a).toPoint",
          "bird->mapFromScene"
        ]
      },
      {
        "function_name": "Physics::collisionCheck()",
        "params": "()",
        "body": "{\r\n    bool bTrue = true;\r\n\r\n    if(collisionDetectionDisabled)\r\n        bTrue = false;\r\n\r\n    birdRect.x = bird->x();\r\n    birdRect.y = bird->y();\r\n    birdRect.width = bird->x() + bird->boundingRect().width();\r\n    birdRect.height = bird->y() + bird->boundingRect().height();\r\n\r\n    if(((birdRect.width > game->scene->pipe[1][1]->pos().x()) &&\r\n        (birdRect.width < game->scene->pipe[1][1]->boundingRect().width() + game->scene->pipe[1][1]->pos().x())) &&\r\n            (birdRect.height > game->scene->pipe[1][1]->pos().y() ||\r\n             birdRect.height < game->scene->pipe[0][1]->pos().y() + game->scene->pipe[0][1]->boundingRect().height()))\r\n    {\r\n        if((complexAnalysis && (collisionCheckComplex(*game->scene->pipe[1][1]) ||\r\n                                collisionCheckComplex(*game->scene->pipe[0][1]))) || !complexAnalysis)\r\n        {\r\n            return bTrue;\r\n        }\r\n    }\r\n    else if((birdRect.width >= game->scene->pipe[1][1]->pos().x() &&\r\n             birdRect.x <= game->scene->pipe[1][1]->pos().x() + game->scene->pipe[1][1]->boundingRect().width()) &&\r\n            (birdRect.height > game->scene->pipe[1][1]->pos().y() ||\r\n             birdRect.y < game->scene->pipe[0][1]->pos().y() + game->scene->pipe[0][1]->boundingRect().height()))\r\n    {\r\n        if((complexAnalysis && (collisionCheckComplex(*game->scene->pipe[1][1]) ||\r\n                                collisionCheckComplex(*game->scene->pipe[0][1]))) || !complexAnalysis)\r\n        {\r\n            return bTrue;\r\n        }\r\n    }\r\n\r\n    if(((birdRect.width > game->scene->pipe[1][2]->pos().x()) &&\r\n        (birdRect.width < game->scene->pipe[1][2]->boundingRect().width() + game->scene->pipe[1][2]->pos().x())) &&\r\n            (birdRect.height > game->scene->pipe[1][2]->pos().y() ||\r\n             birdRect.height < game->scene->pipe[0][2]->pos().y() + game->scene->pipe[0][2]->boundingRect().height()))\r\n    {\r\n        if((complexAnalysis && (collisionCheckComplex(*game->scene->pipe[1][2]) ||\r\n                                collisionCheckComplex(*game->scene->pipe[0][2]))) || !complexAnalysis)\r\n        {\r\n            return bTrue;\r\n        }\r\n    }\r\n    else if((birdRect.width >= game->scene->pipe[1][2]->pos().x() &&\r\n             birdRect.x <= game->scene->pipe[1][2]->pos().x() + game->scene->pipe[1][2]->boundingRect().width()) &&\r\n            (birdRect.height > game->scene->pipe[1][2]->pos().y() ||\r\n             birdRect.y < game->scene->pipe[0][2]->pos().y() + game->scene->pipe[0][2]->boundingRect().height()))\r\n    {\r\n        if((complexAnalysis && (collisionCheckComplex(*game->scene->pipe[1][2]) ||\r\n                                collisionCheckComplex(*game->scene->pipe[0][2]))) || !complexAnalysis)\r\n        {\r\n            return bTrue;\r\n        }\r\n    }\r\n\r\n    if(((birdRect.width > game->scene->pipe[1][0]->pos().x()) &&\r\n        (birdRect.width < game->scene->pipe[1][0]->boundingRect().width() + game->scene->pipe[1][0]->pos().x())) &&\r\n            (birdRect.height > game->scene->pipe[1][0]->pos().y() ||\r\n             birdRect.height < game->scene->pipe[0][0]->pos().y() + game->scene->pipe[0][0]->boundingRect().height()))\r\n    {\r\n        if((complexAnalysis && (collisionCheckComplex(*game->scene->pipe[1][0]) ||\r\n                                collisionCheckComplex(*game->scene->pipe[0][0]))) || !complexAnalysis)\r\n        {\r\n            return bTrue;\r\n        }\r\n    }\r\n    else if((birdRect.width >= game->scene->pipe[1][0]->pos().x() &&\r\n             birdRect.x <= game->scene->pipe[1][0]->pos().x() + game->scene->pipe[1][0]->boundingRect().width()) &&\r\n            (birdRect.height > game->scene->pipe[1][0]->pos().y() ||\r\n             birdRect.y < game->scene->pipe[0][0]->pos().y() + game->scene->pipe[0][0]->boundingRect().height()))\r\n    {\r\n        if((complexAnalysis && (collisionCheckComplex(*game->scene->pipe[1][0]) ||\r\n                                collisionCheckComplex(*game->scene->pipe[0][0]))) || !complexAnalysis)\r\n        {\r\n            return bTrue;\r\n        }\r\n    }\r\n\r\n\r\n\r\n    if((birdRect.y < -bird->boundingRect().height()) || (birdRect.height > game->scene->ground->pos().y()))\r\n    {\r\n        return bTrue;\r\n    }\r\n\r\n\r\n\r\n    if((birdRect.x >= game->scene->pipe[1][0]->pos().x() + game->scene->pipe[1][0]->boundingRect().width()) &&\r\n            markers[0] == 0 && (birdRect.width < game->scene->pipe[1][1]->pos().x()))\r\n    {\r\n        game->updateScore();\r\n        markers[0] = 1;\r\n        markers[2] = 0;\r\n        game->birdClosestPipe = 2;\r\n    }\r\n    else if((birdRect.x >= game->scene->pipe[1][1]->pos().x() + game->scene->pipe[1][1]->boundingRect().width()) &&\r\n            markers[1] == 0 && (birdRect.width < game->scene->pipe[1][2]->pos().x()))\r\n    {\r\n        game->updateScore();\r\n        markers[0] = 0;\r\n        markers[1] = 1;\r\n        game->birdClosestPipe = 0;\r\n    }\r\n    else if((birdRect.x >= game->scene->pipe[1][2]->pos().x() + game->scene->pipe[1][2]->boundingRect().width()) &&\r\n            markers[2] == 0 && (birdRect.width < game->scene->pipe[1][0]->pos().x()))\r\n    {\r\n        game->updateScore();\r\n        markers[1] = 0;\r\n        markers[2] = 1;\r\n        game->birdClosestPipe = 1;\r\n    }\r\n\r\n    return false;\r\n}",
        "calls": [
          "bird->x",
          "bird->y",
          "bird->x",
          "bird->boundingRect().width",
          "bird->boundingRect",
          "bird->y",
          "bird->boundingRect().height",
          "bird->boundingRect",
          "game->scene->pipe[1][1]->pos().x",
          "game->scene->pipe[1][1]->pos",
          "game->scene->pipe[1][1]->boundingRect().width",
          "game->scene->pipe[1][1]->boundingRect",
          "game->scene->pipe[1][1]->pos().x",
          "game->scene->pipe[1][1]->pos",
          "game->scene->pipe[1][1]->pos().y",
          "game->scene->pipe[1][1]->pos",
          "game->scene->pipe[0][1]->pos().y",
          "game->scene->pipe[0][1]->pos",
          "game->scene->pipe[0][1]->boundingRect().height",
          "game->scene->pipe[0][1]->boundingRect",
          "collisionCheckComplex",
          "collisionCheckComplex",
          "game->scene->pipe[1][1]->pos().x",
          "game->scene->pipe[1][1]->pos",
          "game->scene->pipe[1][1]->pos().x",
          "game->scene->pipe[1][1]->pos",
          "game->scene->pipe[1][1]->boundingRect().width",
          "game->scene->pipe[1][1]->boundingRect",
          "game->scene->pipe[1][1]->pos().y",
          "game->scene->pipe[1][1]->pos",
          "game->scene->pipe[0][1]->pos().y",
          "game->scene->pipe[0][1]->pos",
          "game->scene->pipe[0][1]->boundingRect().height",
          "game->scene->pipe[0][1]->boundingRect",
          "collisionCheckComplex",
          "collisionCheckComplex",
          "game->scene->pipe[1][2]->pos().x",
          "game->scene->pipe[1][2]->pos",
          "game->scene->pipe[1][2]->boundingRect().width",
          "game->scene->pipe[1][2]->boundingRect",
          "game->scene->pipe[1][2]->pos().x",
          "game->scene->pipe[1][2]->pos",
          "game->scene->pipe[1][2]->pos().y",
          "game->scene->pipe[1][2]->pos",
          "game->scene->pipe[0][2]->pos().y",
          "game->scene->pipe[0][2]->pos",
          "game->scene->pipe[0][2]->boundingRect().height",
          "game->scene->pipe[0][2]->boundingRect",
          "collisionCheckComplex",
          "collisionCheckComplex",
          "game->scene->pipe[1][2]->pos().x",
          "game->scene->pipe[1][2]->pos",
          "game->scene->pipe[1][2]->pos().x",
          "game->scene->pipe[1][2]->pos",
          "game->scene->pipe[1][2]->boundingRect().width",
          "game->scene->pipe[1][2]->boundingRect",
          "game->scene->pipe[1][2]->pos().y",
          "game->scene->pipe[1][2]->pos",
          "game->scene->pipe[0][2]->pos().y",
          "game->scene->pipe[0][2]->pos",
          "game->scene->pipe[0][2]->boundingRect().height",
          "game->scene->pipe[0][2]->boundingRect",
          "collisionCheckComplex",
          "collisionCheckComplex",
          "game->scene->pipe[1][0]->pos().x",
          "game->scene->pipe[1][0]->pos",
          "game->scene->pipe[1][0]->boundingRect().width",
          "game->scene->pipe[1][0]->boundingRect",
          "game->scene->pipe[1][0]->pos().x",
          "game->scene->pipe[1][0]->pos",
          "game->scene->pipe[1][0]->pos().y",
          "game->scene->pipe[1][0]->pos",
          "game->scene->pipe[0][0]->pos().y",
          "game->scene->pipe[0][0]->pos",
          "game->scene->pipe[0][0]->boundingRect().height",
          "game->scene->pipe[0][0]->boundingRect",
          "collisionCheckComplex",
          "collisionCheckComplex",
          "game->scene->pipe[1][0]->pos().x",
          "game->scene->pipe[1][0]->pos",
          "game->scene->pipe[1][0]->pos().x",
          "game->scene->pipe[1][0]->pos",
          "game->scene->pipe[1][0]->boundingRect().width",
          "game->scene->pipe[1][0]->boundingRect",
          "game->scene->pipe[1][0]->pos().y",
          "game->scene->pipe[1][0]->pos",
          "game->scene->pipe[0][0]->pos().y",
          "game->scene->pipe[0][0]->pos",
          "game->scene->pipe[0][0]->boundingRect().height",
          "game->scene->pipe[0][0]->boundingRect",
          "collisionCheckComplex",
          "collisionCheckComplex",
          "bird->boundingRect().height",
          "bird->boundingRect",
          "game->scene->ground->pos().y",
          "game->scene->ground->pos",
          "game->scene->pipe[1][0]->pos().x",
          "game->scene->pipe[1][0]->pos",
          "game->scene->pipe[1][0]->boundingRect().width",
          "game->scene->pipe[1][0]->boundingRect",
          "game->scene->pipe[1][1]->pos().x",
          "game->scene->pipe[1][1]->pos",
          "game->updateScore",
          "game->scene->pipe[1][1]->pos().x",
          "game->scene->pipe[1][1]->pos",
          "game->scene->pipe[1][1]->boundingRect().width",
          "game->scene->pipe[1][1]->boundingRect",
          "game->scene->pipe[1][2]->pos().x",
          "game->scene->pipe[1][2]->pos",
          "game->updateScore",
          "game->scene->pipe[1][2]->pos().x",
          "game->scene->pipe[1][2]->pos",
          "game->scene->pipe[1][2]->boundingRect().width",
          "game->scene->pipe[1][2]->boundingRect",
          "game->scene->pipe[1][0]->pos().x",
          "game->scene->pipe[1][0]->pos",
          "game->updateScore"
        ]
      },
      {
        "function_name": "Physics::randInt(int low, int high)",
        "params": "(int low, int high)",
        "body": "{\r\n    return qrand() % ((high + 1) - low) + low;\r\n}",
        "calls": [
          "qrand"
        ]
      },
      {
        "function_name": "Physics::movePipes()",
        "params": "()",
        "body": "{\r\n    if((game->scene->pipe[1][1]->pos().x() >= game->getScreenWidth()) && (pipeMarkers[0] == 0))\r\n    {\r\n\r\n        if(pipeMarkers[1])\r\n        {\r\n            game->scene->pipe[1][1]->setPos(game->getScreenWidth() + (game->scene->pipe[1][1]->boundingRect().width()) + (game->getScreenWidth() / 2.6),randInt(game->getScreenHeight()/3.7,game->getScreenHeight() / 1.4));\r\n        }\r\n        else\r\n        {\r\n            game->scene->pipe[1][1]->setPos(game->getScreenWidth() + (game->scene->pipe[1][1]->boundingRect().width()),randInt(game->getScreenHeight() / 3.5,game->getScreenHeight() / 1.4));\r\n        }\r\n        game->scene->pipe[0][1]->setPos(game->scene->pipe[1][1]->pos().x(),game->scene->pipe[1][1]->pos().y() - (game->getScreenHeight() / 5.05) - game->scene->pipe[1][1]->boundingRect().height());\r\n        pipeMarkers[0] = 1;\r\n    }\r\n    if((game->scene->pipe[1][0]->pos().x() >= game->getScreenWidth()) && (pipeMarkers[2] == 0))\r\n    {\r\n        if(pipeMarkers[1])\r\n        {\r\n            game->scene->pipe[1][0]->setPos(game->getScreenWidth() + game->scene->pipe[1][0]->boundingRect().width() + (game->getScreenWidth() / 2.6),randInt(game->getScreenHeight()/3.7,game->getScreenHeight() / 1.4));\r\n        }\r\n        else\r\n        {\r\n            game->scene->pipe[1][0]->setPos(game->scene->pipe[1][1]->pos().x() + (game->getScreenWidth() / 2.6) + (game->scene->pipe[1][0]->boundingRect().width()),randInt(game->getScreenHeight() / 3.7,game->getScreenHeight() / 1.4));\r\n        }\r\n        game->scene->pipe[0][0]->setPos(game->scene->pipe[1][0]->pos().x(),game->scene->pipe[1][0]->pos().y() - (game->getScreenHeight() / 5.05) - game->scene->pipe[1][0]->boundingRect().height());\r\n        pipeMarkers[2] = 1;\r\n    }\r\n    if(game->scene->pipe[1][2]->pos().x() >= game->getScreenWidth() && (pipeMarkers[3] == 0))\r\n    {\r\n        if(pipeMarkers[1])\r\n        {\r\n            game->scene->pipe[1][2]->setPos(game->getScreenWidth() + game->scene->pipe[1][2]->boundingRect().width() + (game->getScreenWidth() / 2.6),randInt(game->getScreenHeight() / 3.7,game->getScreenHeight() / 1.4));\r\n        }\r\n        else\r\n        {\r\n            game->scene->pipe[1][2]->setPos(game->scene->pipe[1][0]->pos().x() + (game->getScreenWidth() / 2.6) + (game->scene->pipe[1][2]->boundingRect().width()),randInt(game->getScreenHeight() / 3.7,game->getScreenHeight() / 1.4));\r\n        }\r\n        game->scene->pipe[0][2]->setPos(game->scene->pipe[1][2]->pos().x(),game->scene->pipe[1][2]->pos().y() - (game->getScreenHeight() / 5.05) - game->scene->pipe[0][2]->boundingRect().height());\r\n        pipeMarkers[3] = 1;\r\n    }\r\n\r\n    game->scene->pipe[1][1]->setPos(game->scene->pipe[1][1]->pos().x() - (PHYSICS_UNIT_MOVE_RATE(game->getScreenWidth()) * speedfactor), game->scene->pipe[1][1]->y());\r\n    game->scene->pipe[0][1]->setPos(game->scene->pipe[0][1]->pos().x() - (PHYSICS_UNIT_MOVE_RATE(game->getScreenWidth()) * speedfactor), game->scene->pipe[0][1]->y());\r\n    game->scene->pipe[1][0]->setPos(game->scene->pipe[1][0]->pos().x() - (PHYSICS_UNIT_MOVE_RATE(game->getScreenWidth()) * speedfactor), game->scene->pipe[1][0]->y());\r\n    game->scene->pipe[0][0]->setPos(game->scene->pipe[0][0]->pos().x() - (PHYSICS_UNIT_MOVE_RATE(game->getScreenWidth()) * speedfactor), game->scene->pipe[0][0]->y());\r\n    game->scene->pipe[1][2]->setPos(game->scene->pipe[1][2]->pos().x() - (PHYSICS_UNIT_MOVE_RATE(game->getScreenWidth()) * speedfactor), game->scene->pipe[1][2]->y());\r\n    game->scene->pipe[0][2]->setPos(game->scene->pipe[0][2]->pos().x() - (PHYSICS_UNIT_MOVE_RATE(game->getScreenWidth()) * speedfactor), game->scene->pipe[0][2]->y());\r\n\r\n    if(game->scene->pipe[1][1]->pos().x() < -game->scene->pipe[1][1]->boundingRect().width())\r\n    {\r\n        pipeMarkers[0] = 0;\r\n        pipeMarkers[1] = 1;\r\n        game->scene->pipe[1][1]->setPos(game->getScreenWidth(), 0);\r\n    }\r\n    if(game->scene->pipe[1][0]->pos().x() < -game->scene->pipe[1][0]->boundingRect().width())\r\n    {\r\n        pipeMarkers[2] = 0;\r\n        pipeMarkers[1] = 1;\r\n        game->scene->pipe[1][0]->setPos(game->getScreenWidth(), 0);\r\n    }\r\n    if(game->scene->pipe[1][2]->pos().x() < -game->scene->pipe[1][2]->boundingRect().width())\r\n    {\r\n        pipeMarkers[3] = 0;\r\n        pipeMarkers[1] = 1;\r\n        game->scene->pipe[1][2]->setPos(game->getScreenWidth(), 0);\r\n    }\r\n}",
        "calls": [
          "game->scene->pipe[1][1]->pos().x",
          "game->scene->pipe[1][1]->pos",
          "game->getScreenWidth",
          "game->scene->pipe[1][1]->setPos",
          "game->getScreenWidth",
          "game->scene->pipe[1][1]->boundingRect().width",
          "game->scene->pipe[1][1]->boundingRect",
          "game->getScreenWidth",
          "randInt",
          "game->getScreenHeight",
          "game->getScreenHeight",
          "game->scene->pipe[1][1]->setPos",
          "game->getScreenWidth",
          "game->scene->pipe[1][1]->boundingRect().width",
          "game->scene->pipe[1][1]->boundingRect",
          "randInt",
          "game->getScreenHeight",
          "game->getScreenHeight",
          "game->scene->pipe[0][1]->setPos",
          "game->scene->pipe[1][1]->pos().x",
          "game->scene->pipe[1][1]->pos",
          "game->scene->pipe[1][1]->pos().y",
          "game->scene->pipe[1][1]->pos",
          "game->getScreenHeight",
          "game->scene->pipe[1][1]->boundingRect().height",
          "game->scene->pipe[1][1]->boundingRect",
          "game->scene->pipe[1][0]->pos().x",
          "game->scene->pipe[1][0]->pos",
          "game->getScreenWidth",
          "game->scene->pipe[1][0]->setPos",
          "game->getScreenWidth",
          "game->scene->pipe[1][0]->boundingRect().width",
          "game->scene->pipe[1][0]->boundingRect",
          "game->getScreenWidth",
          "randInt",
          "game->getScreenHeight",
          "game->getScreenHeight",
          "game->scene->pipe[1][0]->setPos",
          "game->scene->pipe[1][1]->pos().x",
          "game->scene->pipe[1][1]->pos",
          "game->getScreenWidth",
          "game->scene->pipe[1][0]->boundingRect().width",
          "game->scene->pipe[1][0]->boundingRect",
          "randInt",
          "game->getScreenHeight",
          "game->getScreenHeight",
          "game->scene->pipe[0][0]->setPos",
          "game->scene->pipe[1][0]->pos().x",
          "game->scene->pipe[1][0]->pos",
          "game->scene->pipe[1][0]->pos().y",
          "game->scene->pipe[1][0]->pos",
          "game->getScreenHeight",
          "game->scene->pipe[1][0]->boundingRect().height",
          "game->scene->pipe[1][0]->boundingRect",
          "game->scene->pipe[1][2]->pos().x",
          "game->scene->pipe[1][2]->pos",
          "game->getScreenWidth",
          "game->scene->pipe[1][2]->setPos",
          "game->getScreenWidth",
          "game->scene->pipe[1][2]->boundingRect().width",
          "game->scene->pipe[1][2]->boundingRect",
          "game->getScreenWidth",
          "randInt",
          "game->getScreenHeight",
          "game->getScreenHeight",
          "game->scene->pipe[1][2]->setPos",
          "game->scene->pipe[1][0]->pos().x",
          "game->scene->pipe[1][0]->pos",
          "game->getScreenWidth",
          "game->scene->pipe[1][2]->boundingRect().width",
          "game->scene->pipe[1][2]->boundingRect",
          "randInt",
          "game->getScreenHeight",
          "game->getScreenHeight",
          "game->scene->pipe[0][2]->setPos",
          "game->scene->pipe[1][2]->pos().x",
          "game->scene->pipe[1][2]->pos",
          "game->scene->pipe[1][2]->pos().y",
          "game->scene->pipe[1][2]->pos",
          "game->getScreenHeight",
          "game->scene->pipe[0][2]->boundingRect().height",
          "game->scene->pipe[0][2]->boundingRect",
          "game->scene->pipe[1][1]->setPos",
          "game->scene->pipe[1][1]->pos().x",
          "game->scene->pipe[1][1]->pos",
          "PHYSICS_UNIT_MOVE_RATE",
          "game->getScreenWidth",
          "game->scene->pipe[1][1]->y",
          "game->scene->pipe[0][1]->setPos",
          "game->scene->pipe[0][1]->pos().x",
          "game->scene->pipe[0][1]->pos",
          "PHYSICS_UNIT_MOVE_RATE",
          "game->getScreenWidth",
          "game->scene->pipe[0][1]->y",
          "game->scene->pipe[1][0]->setPos",
          "game->scene->pipe[1][0]->pos().x",
          "game->scene->pipe[1][0]->pos",
          "PHYSICS_UNIT_MOVE_RATE",
          "game->getScreenWidth",
          "game->scene->pipe[1][0]->y",
          "game->scene->pipe[0][0]->setPos",
          "game->scene->pipe[0][0]->pos().x",
          "game->scene->pipe[0][0]->pos",
          "PHYSICS_UNIT_MOVE_RATE",
          "game->getScreenWidth",
          "game->scene->pipe[0][0]->y",
          "game->scene->pipe[1][2]->setPos",
          "game->scene->pipe[1][2]->pos().x",
          "game->scene->pipe[1][2]->pos",
          "PHYSICS_UNIT_MOVE_RATE",
          "game->getScreenWidth",
          "game->scene->pipe[1][2]->y",
          "game->scene->pipe[0][2]->setPos",
          "game->scene->pipe[0][2]->pos().x",
          "game->scene->pipe[0][2]->pos",
          "PHYSICS_UNIT_MOVE_RATE",
          "game->getScreenWidth",
          "game->scene->pipe[0][2]->y",
          "game->scene->pipe[1][1]->pos().x",
          "game->scene->pipe[1][1]->pos",
          "game->scene->pipe[1][1]->boundingRect().width",
          "game->scene->pipe[1][1]->boundingRect",
          "game->scene->pipe[1][1]->setPos",
          "game->getScreenWidth",
          "game->scene->pipe[1][0]->pos().x",
          "game->scene->pipe[1][0]->pos",
          "game->scene->pipe[1][0]->boundingRect().width",
          "game->scene->pipe[1][0]->boundingRect",
          "game->scene->pipe[1][0]->setPos",
          "game->getScreenWidth",
          "game->scene->pipe[1][2]->pos().x",
          "game->scene->pipe[1][2]->pos",
          "game->scene->pipe[1][2]->boundingRect().width",
          "game->scene->pipe[1][2]->boundingRect",
          "game->scene->pipe[1][2]->setPos",
          "game->getScreenWidth"
        ]
      },
      {
        "function_name": "Physics::switchOnlyGroundMove()",
        "params": "()",
        "body": "{\r\n    physicsTimer->setInterval(onlyGround ? updateInterval : updateInterval * PHYSICS_ONLYGROUND_SLOW_RATE);\r\n    onlyGround = !onlyGround;\r\n}",
        "calls": [
          "physicsTimer->setInterval"
        ]
      }
    ]
  },
  "Flappy-Bird-Qt\\source\\Physics\\Physics.h": {
    "includes": [
      "#include \"common.h\"\r\n"
    ],
    "functions": []
  },
  "Flappy-Bird-Qt\\source\\Scene\\Scene.cpp": {
    "includes": [
      "#include \"Scene.h\"\r\n",
      "#include <QTransform>\r\n",
      "#include <QTimer>\r\n",
      "#include <QGraphicsSceneMouseEvent>\r\n",
      "#include <QGraphicsOpacityEffect>\r\n",
      "#include <QKeyEvent>\r\n",
      "#include <QPropertyAnimation>\r\n",
      "#include <QPainter>\r\n",
      "#include \"Game/Game.h\"\r\n",
      "#include \"View/View.h\"\r\n",
      "#include \"Bird/Bird.h\"\r\n",
      "#include \"Button/Button.h\"\r\n"
    ],
    "functions": [
      {
        "function_name": "Scene::Scene(Game *parent_game, const QRectF& rect)",
        "params": "(Game *parent_game, const QRectF& rect)",
        "body": "{\r\n    QPainter _painter;\r\n\r\n    flashStatus = false;\r\n\r\n    isClickAvailable[0] = true;\r\n    isClickAvailable[1] = true;\r\n\r\n    QPixmap background(IMG_BACKGROUND_DAY);\r\n    background = background.scaled(game->getScreenWidth(), game->getScreenHeight());\r\n    game->graphicsView->setBackgroundBrush(QBrush(background));\r\n\r\n    game->graphicsView->setScene(this);\r\n    game->graphicsView->setSceneRect(sceneRect());\r\n\r\n\r\n    QPixmap pixmap_logo(IMG_LOGO);\r\n    PIXMAP_SCALE(pixmap_logo, game->getScaleFactor())\r\n    item_pixmap_logo = new QGraphicsPixmapItem(pixmap_logo);\r\n    item_pixmap_logo->setPos((game->getScreenWidth() / 2) - (pixmap_logo.width() / 2), POS_Y_LOGO(game->getScreenHeight()));\r\n\r\n    QPixmap pixmap_ground(IMG_GROUND_SEGMENT);\r\n    PIXMAP_SCALE(pixmap_ground, game->getScaleFactor())\r\n    groundImage = QImage(game->getScreenWidth() * 2, pixmap_ground.height(), QImage::Format_RGB32);\r\n    groundImage.fill(0);\r\n    groundPainter = new QPainter();\r\n    groundPainter->begin(&groundImage);\r\n    int _indicator = 0;\r\n    int _counter = 0;\r\n    for(; _counter < ((game->getScreenWidth() * 2) / pixmap_ground.width()); ++_counter)\r\n    {\r\n        groundPainter->drawPixmap(_indicator, 0, pixmap_ground.width(), pixmap_ground.height(), pixmap_ground);\r\n        _indicator += pixmap_ground.width();\r\n    }\r\n    groundPainter->end();\r\n\r\n    QImage buffer((_counter - 1) * pixmap_ground.width(), pixmap_ground.height(), QImage::Format_RGB32);\r\n    buffer = groundImage.copy(0,0,(_counter - 1) * pixmap_ground.width(), pixmap_ground.height());\r\n    groundImage = buffer.scaledToWidth(groundImage.width());\r\n    ground = new QGraphicsPixmapItem(QPixmap::fromImage(groundImage));\r\n    ground->setPos(0, game->getScreenHeight() - groundImage.height() + groundImage.height() / 7);\r\n\r\n    QPixmap pixmap_play(IMG_BUTTON_PLAY);\r\n    PIXMAP_SCALE(pixmap_play, game->getScaleFactor())\r\n    item_button_play = new Button(game, pixmap_play, ButtonFuncs::play);\r\n    item_button_play->setPos(game->getScreenWidth() / 2 - pixmap_play.width() * 1.2, ground->y() - pixmap_play.height());\r\n\r\n    QPixmap pixmap_about(IMG_BUTTON_ABOUT);\r\n    PIXMAP_SCALE(pixmap_about, game->getScaleFactor())\r\n    item_button_about = new Button(game, pixmap_about, ButtonFuncs::about);\r\n    item_button_about->setPos(game->getScreenWidth() - item_button_play->x() - pixmap_about.width(), item_button_play->y());\r\n\r\n    QPixmap pixmap_soundEnabled(IMG_SOUND_ENABLED);\r\n    QPixmap pixmap_soundDisabled(IMG_SOUND_DISABLED);\r\n    PIXMAP_SCALE(pixmap_soundDisabled, game->getScaleFactor());\r\n    PIXMAP_SCALE(pixmap_soundEnabled, game->getScaleFactor());\r\n    if(game->isSoundEnabled())\r\n    {\r\n        item_button_sound = new Button(game, pixmap_soundEnabled, ButtonFuncs::soundDisable, true, pixmap_soundDisabled, ButtonFuncs::soundEnable);\r\n    }\r\n    else\r\n    {\r\n        item_button_sound = new Button(game, pixmap_soundDisabled, ButtonFuncs::soundEnable, true, pixmap_soundEnabled, ButtonFuncs::soundDisable);\r\n    }\r\n    item_button_sound->setPos(game->getScreenWidth() - pixmap_soundEnabled.width(), 0);\r\n\r\n#ifndef AI_DISABLED\r\n    QPixmap pixmap_AIEnabled(IMG_AI);\r\n    PIXMAP_SCALE(pixmap_AIEnabled, game->getScaleFactor());\r\n    item_button_AI = new Button(game, pixmap_AIEnabled, ButtonFuncs::aiEnable);\r\n    item_button_AI->setPos(0, 0);\r\n\r\n    //if(game->isAIEnabled())\r\n    //{\r\n        QPixmap pixmap_AIPlay(IMG_AIPLAY);\r\n        PIXMAP_SCALE(pixmap_AIPlay, game->getScaleFactor());\r\n        item_button_AIPlay = new Button(game, pixmap_AIPlay, ButtonFuncs::aiPlay);\r\n        item_button_AIPlay->setPos(0, 0);\r\n        item_button_AIPlay->setVisible(false);\r\n    //}\r\n    //else\r\n    //{\r\n    //    item_button_AIPlay = nullptr;\r\n    //}\r\n#else\r\n    item_button_AI = nullptr;\r\n    item_button_AIPlay = nullptr;\r\n#endif\r\n\r\n    QPixmap pixmap_pipe_down(IMG_PIPE_DOWN);\r\n    QPixmap pixmap_pipe_up(IMG_PIPE_UP);\r\n    PIXMAP_SCALE(pixmap_pipe_down, game->getScaleFactor())\r\n    PIXMAP_SCALE(pixmap_pipe_up, game->getScaleFactor())\r\n\r\n    pipe[0][0] = new QGraphicsPixmapItem(pixmap_pipe_down);\r\n    pipe[0][1] = new QGraphicsPixmapItem(pixmap_pipe_down);\r\n    pipe[0][2] = new QGraphicsPixmapItem(pixmap_pipe_down);\r\n    pipe[1][0] = new QGraphicsPixmapItem(pixmap_pipe_up);\r\n    pipe[1][1] = new QGraphicsPixmapItem(pixmap_pipe_up);\r\n    pipe[1][2] = new QGraphicsPixmapItem(pixmap_pipe_up);\r\n\r\n\r\n    QPixmap pixmap_gameInfo(IMG_GAMEINFO);\r\n    PIXMAP_SCALE(pixmap_gameInfo, game->getScaleFactor())\r\n    item_pixmap_gameInfo = new QGraphicsPixmapItem(pixmap_gameInfo);\r\n    item_pixmap_gameInfo->setPos(game->getScreenWidth() / 2 - pixmap_gameInfo.width() / 2, game->getScreenHeight() / 2 - pixmap_gameInfo.height() / 3);\r\n    item_pixmap_gameInfo->setVisible(false);\r\n\r\n    QPixmap pixmap_gameReady(IMG_READY);\r\n    PIXMAP_SCALE(pixmap_gameReady, game->getScaleFactor())\r\n    item_pixmap_gameReady = new QGraphicsPixmapItem(pixmap_gameReady);\r\n    item_pixmap_gameReady->setPos(game->getScreenWidth() / 2 - pixmap_gameReady.width() / 2, item_pixmap_gameInfo->y() - pixmap_gameReady.height() * 1.6);\r\n    item_pixmap_gameReady->setVisible(false);\r\n\r\n    QPixmap pixmap_gameOver(IMG_GAMEOVER);\r\n    PIXMAP_SCALE(pixmap_gameOver, game->getScaleFactor())\r\n    item_pixmap_gameOver = new QGraphicsPixmapItem(pixmap_gameOver);\r\n    item_pixmap_gameOver->setPos(item_pixmap_logo->pos());\r\n    item_pixmap_gameOver->setVisible(false);\r\n\r\n    QPixmap pixmap_scoreBoard(IMG_SCOREBOARD);\r\n    PIXMAP_SCALE(pixmap_scoreBoard, game->getScaleFactor())\r\n    item_pixmap_scoreBoard = new QGraphicsPixmapItem(pixmap_scoreBoard);\r\n    item_pixmap_scoreBoard->setPos(game->getScreenWidth() / 2 - pixmap_scoreBoard.width() / 2, item_pixmap_gameOver->y() + item_pixmap_gameOver->boundingRect().height() + (game->getScreenHeight() / 20.69));\r\n    item_pixmap_scoreBoard->setVisible(false);\r\n\r\n    pixmap_bigZero = QPixmap(IMG_BIGNUMBER_ZERO);\r\n    PIXMAP_SCALE(pixmap_bigZero, game->getScaleFactor())\r\n    image_mainScore = QImage(pixmap_bigZero.width() * 3, pixmap_bigZero.height(), QImage::Format_ARGB32);\r\n    image_mainScore.fill(qRgba(0, 0, 0, 0));\r\n\r\n    _painter.begin(&image_mainScore);\r\n    _painter.drawPixmap(0, 0, pixmap_bigZero.width(), pixmap_bigZero.height(), pixmap_bigZero);\r\n    _painter.end();\r\n    item_pixmap_score = new QGraphicsPixmapItem(pixmap_bigZero);\r\n    item_pixmap_score->setVisible(false);\r\n    item_pixmap_score->setPos(game->getScreenWidth() / 2 - pixmap_bigZero.width() / 2, pixmap_bigZero.height() * 2);\r\n\r\n\r\n    pixmap_smallZero = QPixmap(IMG_SMALLNUMBER_ZERO);\r\n    PIXMAP_SCALE(pixmap_smallZero, game->getScaleFactor())\r\n    image_endScore = QImage(pixmap_scoreBoard.width(), pixmap_smallZero.height(), QImage::Format_ARGB32);\r\n    image_endScore.fill(qRgba(0,0,0,0));\r\n    item_pixmap_endScore = new QGraphicsPixmapItem();\r\n    item_pixmap_endScore->setVisible(false);\r\n\r\n    item_pixmap_endScoreRecord = new QGraphicsPixmapItem();\r\n    item_pixmap_endScoreRecord->setVisible(false);\r\n\r\n    QPixmap pixmap_info(IMG_INFO);\r\n    // PIXMAP_SCALE(pixmap_info, game->getScaleFactor())\r\n    item_pixmap_info = new QGraphicsPixmapItem(pixmap_info);\r\n    item_pixmap_info->setPos(game->getScreenWidth() - pixmap_info.width(), game->getScreenHeight() - pixmap_info.height());\r\n\r\n    QPixmap pixmap_bird_raw(IMG_BIRD_YELLOW_UP);\r\n    QPixmap pixmap_bird = pixmap_bird_raw;\r\n    PIXMAP_SCALE(pixmap_bird, game->getScaleFactor())\r\n    QPointF pos_bird(game->getScreenWidth() / 2 - pixmap_bird_raw.width() / 2, item_pixmap_logo->pos().y() + pixmap_bird_raw.height() * 5);\r\n    bird = new Bird(pos_bird, pixmap_bird, game->getScreenHeight() - ground->boundingRect().height(), game->getScreenWidth(), game->getScreenHeight(), game->getScaleFactor());\r\n\r\n    // FIX: Use QList instead\r\n    button[0] = item_button_play;\r\n    button[1] = item_button_about;\r\n    button[2] = item_button_sound;\r\n    button[3] = item_button_AI;\r\n    button[4] = item_button_AIPlay;\r\n    button[5] = nullptr;\r\n\r\n    // FIX: Use QList instead\r\n    group_item[GROUP_NEWROUND][0] = item_pixmap_gameInfo;\r\n    group_item[GROUP_NEWROUND][1] = item_pixmap_gameReady;\r\n    group_item[GROUP_NEWROUND][2] = item_button_sound;\r\n    group_item[GROUP_NEWROUND][3] = nullptr;\r\n\r\n    group_item[GROUP_GAMEPLAY][0] = item_pixmap_gameInfo;\r\n    group_item[GROUP_GAMEPLAY][1] = item_pixmap_gameReady;\r\n    group_item[GROUP_GAMEPLAY][2] = item_pixmap_score;\r\n    group_item[GROUP_GAMEPLAY][3] = item_button_sound;\r\n    group_item[GROUP_GAMEPLAY][4] = nullptr;\r\n\r\n    group_item[GROUP_ROUNDEND][0] = item_pixmap_scoreBoard;\r\n    group_item[GROUP_ROUNDEND][1] = item_pixmap_gameOver;\r\n    group_item[GROUP_ROUNDEND][2] = item_button_play;\r\n    group_item[GROUP_ROUNDEND][3] = item_pixmap_endScore;\r\n    group_item[GROUP_ROUNDEND][4] = item_pixmap_endScoreRecord;\r\n    // group_item[GROUP_ROUNDEND][5] = item_button_AIPlay;\r\n    group_item[GROUP_ROUNDEND][5] = nullptr;\r\n\r\n    group_item[GROUP_FIRSTSCREEN][0] = item_pixmap_logo;\r\n    group_item[GROUP_FIRSTSCREEN][1] = item_button_play;\r\n    group_item[GROUP_FIRSTSCREEN][2] = item_button_about;\r\n    group_item[GROUP_FIRSTSCREEN][3] = item_button_sound;\r\n    group_item[GROUP_FIRSTSCREEN][4] = item_button_AI;\r\n    group_item[GROUP_FIRSTSCREEN][5] = nullptr;\r\n\r\n\r\n    addItem(item_pixmap_logo);\r\n    addItem(pipe[0][0]);\r\n    addItem(pipe[0][1]);\r\n    addItem(pipe[0][2]);\r\n    addItem(pipe[1][0]);\r\n    addItem(pipe[1][1]);\r\n    addItem(pipe[1][2]);\r\n    addItem(item_button_about);\r\n    addItem(item_button_sound);\r\n#ifndef AI_DISABLED\r\n    addItem(item_button_AI);\r\n    addItem(item_button_AIPlay);\r\n#endif\r\n    addItem(item_pixmap_gameReady);\r\n    addItem(item_pixmap_gameInfo);\r\n    addItem(bird);\r\n    addItem(ground);\r\n    addItem(item_pixmap_scoreBoard);\r\n    addItem(item_pixmap_gameOver);\r\n    addItem(item_pixmap_endScore);\r\n    addItem(item_pixmap_endScoreRecord);\r\n    addItem(item_button_play);\r\n    addItem(item_pixmap_score);\r\n    addItem(item_pixmap_info);\r\n}",
        "calls": [
          "background.scaled",
          "game->getScreenWidth",
          "game->getScreenHeight",
          "game->graphicsView->setBackgroundBrush",
          "QBrush",
          "game->graphicsView->setScene",
          "game->graphicsView->setSceneRect",
          "sceneRect",
          "PIXMAP_SCALE",
          "game->getScaleFactor",
          "item_pixmap_logo->setPos",
          "game->getScreenWidth",
          "pixmap_logo.width",
          "POS_Y_LOGO",
          "game->getScreenHeight",
          "PIXMAP_SCALE",
          "game->getScaleFactor",
          "QImage",
          "game->getScreenWidth",
          "pixmap_ground.height",
          "groundImage.fill",
          "groundPainter->begin",
          "game->getScreenWidth",
          "pixmap_ground.width",
          "groundPainter->drawPixmap",
          "pixmap_ground.width",
          "pixmap_ground.height",
          "pixmap_ground.width",
          "groundPainter->end",
          "pixmap_ground.width",
          "pixmap_ground.height",
          "groundImage.copy",
          "pixmap_ground.width",
          "pixmap_ground.height",
          "buffer.scaledToWidth",
          "groundImage.width",
          "QPixmap::fromImage",
          "ground->setPos",
          "game->getScreenHeight",
          "groundImage.height",
          "groundImage.height",
          "PIXMAP_SCALE",
          "game->getScaleFactor",
          "item_button_play->setPos",
          "game->getScreenWidth",
          "pixmap_play.width",
          "ground->y",
          "pixmap_play.height",
          "PIXMAP_SCALE",
          "game->getScaleFactor",
          "item_button_about->setPos",
          "game->getScreenWidth",
          "item_button_play->x",
          "pixmap_about.width",
          "item_button_play->y",
          "PIXMAP_SCALE",
          "game->getScaleFactor",
          "PIXMAP_SCALE",
          "game->getScaleFactor",
          "game->isSoundEnabled",
          "item_button_sound->setPos",
          "game->getScreenWidth",
          "pixmap_soundEnabled.width",
          "PIXMAP_SCALE",
          "game->getScaleFactor",
          "item_button_AI->setPos",
          "PIXMAP_SCALE",
          "game->getScaleFactor",
          "item_button_AIPlay->setPos",
          "item_button_AIPlay->setVisible",
          "PIXMAP_SCALE",
          "game->getScaleFactor",
          "PIXMAP_SCALE",
          "game->getScaleFactor",
          "PIXMAP_SCALE",
          "game->getScaleFactor",
          "item_pixmap_gameInfo->setPos",
          "game->getScreenWidth",
          "pixmap_gameInfo.width",
          "game->getScreenHeight",
          "pixmap_gameInfo.height",
          "item_pixmap_gameInfo->setVisible",
          "PIXMAP_SCALE",
          "game->getScaleFactor",
          "item_pixmap_gameReady->setPos",
          "game->getScreenWidth",
          "pixmap_gameReady.width",
          "item_pixmap_gameInfo->y",
          "pixmap_gameReady.height",
          "item_pixmap_gameReady->setVisible",
          "PIXMAP_SCALE",
          "game->getScaleFactor",
          "item_pixmap_gameOver->setPos",
          "item_pixmap_logo->pos",
          "item_pixmap_gameOver->setVisible",
          "PIXMAP_SCALE",
          "game->getScaleFactor",
          "item_pixmap_scoreBoard->setPos",
          "game->getScreenWidth",
          "pixmap_scoreBoard.width",
          "item_pixmap_gameOver->y",
          "item_pixmap_gameOver->boundingRect().height",
          "item_pixmap_gameOver->boundingRect",
          "game->getScreenHeight",
          "item_pixmap_scoreBoard->setVisible",
          "QPixmap",
          "PIXMAP_SCALE",
          "game->getScaleFactor",
          "QImage",
          "pixmap_bigZero.width",
          "pixmap_bigZero.height",
          "image_mainScore.fill",
          "qRgba",
          "_painter.begin",
          "_painter.drawPixmap",
          "pixmap_bigZero.width",
          "pixmap_bigZero.height",
          "_painter.end",
          "item_pixmap_score->setVisible",
          "item_pixmap_score->setPos",
          "game->getScreenWidth",
          "pixmap_bigZero.width",
          "pixmap_bigZero.height",
          "QPixmap",
          "PIXMAP_SCALE",
          "game->getScaleFactor",
          "QImage",
          "pixmap_scoreBoard.width",
          "pixmap_smallZero.height",
          "image_endScore.fill",
          "qRgba",
          "item_pixmap_endScore->setVisible",
          "item_pixmap_endScoreRecord->setVisible",
          "item_pixmap_info->setPos",
          "game->getScreenWidth",
          "pixmap_info.width",
          "game->getScreenHeight",
          "pixmap_info.height",
          "PIXMAP_SCALE",
          "game->getScaleFactor",
          "game->getScreenWidth",
          "pixmap_bird_raw.width",
          "item_pixmap_logo->pos().y",
          "item_pixmap_logo->pos",
          "pixmap_bird_raw.height",
          "game->getScreenHeight",
          "ground->boundingRect().height",
          "ground->boundingRect",
          "game->getScreenWidth",
          "game->getScreenHeight",
          "game->getScaleFactor",
          "addItem",
          "addItem",
          "addItem",
          "addItem",
          "addItem",
          "addItem",
          "addItem",
          "addItem",
          "addItem",
          "addItem",
          "addItem",
          "addItem",
          "addItem",
          "addItem",
          "addItem",
          "addItem",
          "addItem",
          "addItem",
          "addItem",
          "addItem",
          "addItem",
          "addItem"
        ]
      },
      {
        "function_name": "Scene::~Scene()",
        "params": "()",
        "body": "{\r\n    delete bird;\r\n    delete groundPainter;\r\n}",
        "calls": []
      },
      {
        "function_name": "Scene::isGroupVisible(int groupIndex)",
        "params": "(int groupIndex)",
        "body": "{\r\n    return group_item[groupIndex][0]->isVisible();\r\n}",
        "calls": [
          "group_item[groupIndex][0]->isVisible"
        ]
      },
      {
        "function_name": "Scene::gameOver(int score, int scoreRecord)",
        "params": "(int score, int scoreRecord)",
        "body": "{\r\n    flash(Qt::white, 70, QEasingCurve::Linear);\r\n\r\n    QPixmap reward = QPixmap(IMG_SCOREBOARD);\r\n    if(score >= 10 && score < 20)\r\n        reward = QPixmap(IMG_SCOREBOARD_BRONZE);\r\n    else if(score >= 20 && score < 30)\r\n        reward = QPixmap(IMG_SCOREBOARD_SILVER);\r\n    else if(score >= 30 && score < 40)\r\n        reward = QPixmap(IMG_SCOREBOARD_GOLD);\r\n    else if(score >= 40)\r\n        reward = QPixmap(IMG_SCOREBOARD_PLATINUM);\r\n\r\n    PIXMAP_SCALE(reward, game->getScaleFactor())\r\n    item_pixmap_scoreBoard->setPixmap(reward);\r\n\r\n    int _pos1;\r\n    item_pixmap_endScore->setPixmap(makeEndingScore(score, &_pos1));\r\n    item_pixmap_endScore->setPos(item_pixmap_scoreBoard->x() + item_pixmap_scoreBoard->boundingRect().width() - ((_pos1 + 1) * pixmap_smallZero.width()) - 22 * game->getScaleFactor(), item_pixmap_scoreBoard->y() + pixmap_smallZero.height() * 2.7);\r\n\r\n    int _pos2;\r\n    item_pixmap_endScoreRecord->setPixmap(makeEndingScore(scoreRecord, &_pos2));\r\n    item_pixmap_endScoreRecord->setPos(item_pixmap_endScore->x() - _pos2 * pixmap_smallZero.width() + _pos1 * pixmap_smallZero.width(), item_pixmap_endScore->y() + item_pixmap_endScore->boundingRect().height() + 28.5 * game->getScaleFactor());\r\n\r\n    item_button_play->setPos(game->getScreenWidth() / 2 - item_button_play->boundingRect().width() / 2, item_pixmap_scoreBoard->y() + item_pixmap_scoreBoard->boundingRect().height() + 20);\r\n\r\n    fadeGroup(GROUP_ROUNDEND, true, 500);\r\n}",
        "calls": [
          "flash",
          "QPixmap",
          "QPixmap",
          "QPixmap",
          "QPixmap",
          "QPixmap",
          "PIXMAP_SCALE",
          "game->getScaleFactor",
          "item_pixmap_scoreBoard->setPixmap",
          "item_pixmap_endScore->setPixmap",
          "makeEndingScore",
          "item_pixmap_endScore->setPos",
          "item_pixmap_scoreBoard->x",
          "item_pixmap_scoreBoard->boundingRect().width",
          "item_pixmap_scoreBoard->boundingRect",
          "pixmap_smallZero.width",
          "game->getScaleFactor",
          "item_pixmap_scoreBoard->y",
          "pixmap_smallZero.height",
          "item_pixmap_endScoreRecord->setPixmap",
          "makeEndingScore",
          "item_pixmap_endScoreRecord->setPos",
          "item_pixmap_endScore->x",
          "pixmap_smallZero.width",
          "pixmap_smallZero.width",
          "item_pixmap_endScore->y",
          "item_pixmap_endScore->boundingRect().height",
          "item_pixmap_endScore->boundingRect",
          "game->getScaleFactor",
          "item_button_play->setPos",
          "game->getScreenWidth",
          "item_button_play->boundingRect().width",
          "item_button_play->boundingRect",
          "item_pixmap_scoreBoard->y",
          "item_pixmap_scoreBoard->boundingRect().height",
          "item_pixmap_scoreBoard->boundingRect",
          "fadeGroup"
        ]
      },
      {
        "function_name": "Scene::makeMainScore(int score)",
        "params": "(int score)",
        "body": "{\r\n    QPainter painter;\r\n    image_mainScore.fill(qRgba(0, 0, 0, 0));\r\n    painter.begin(&image_mainScore);\r\n    QString strScore = QString::number(score);\r\n\r\n    int zeroWidth = pixmap_bigZero.width();\r\n    int zeroHeight = pixmap_bigZero.height();\r\n\r\n    QPixmap generatedNumber;\r\n    for(int counter = 0; counter < strScore.length(); ++counter)\r\n    {\r\n        generatedNumber.load(QString(IMG_BIGNUMBER_GENERIC).arg(strScore.mid(counter, 1)));\r\n\r\n        if(counter == 0)\r\n            painter.drawPixmap(counter * zeroWidth, 0, zeroWidth, zeroHeight, generatedNumber);\r\n        else\r\n            painter.drawPixmap(counter * zeroWidth - zeroWidth / 9.25, 0, zeroWidth, zeroHeight, generatedNumber);\r\n    }\r\n    painter.end();\r\n\r\n    return QPixmap::fromImage(image_mainScore);\r\n}",
        "calls": [
          "image_mainScore.fill",
          "qRgba",
          "painter.begin",
          "QString::number",
          "pixmap_bigZero.width",
          "pixmap_bigZero.height",
          "strScore.length",
          "generatedNumber.load",
          "QString(IMG_BIGNUMBER_GENERIC).arg",
          "QString",
          "strScore.mid",
          "painter.drawPixmap",
          "painter.drawPixmap",
          "painter.end",
          "QPixmap::fromImage"
        ]
      },
      {
        "function_name": "Scene::updateScore(int score)",
        "params": "(int score)",
        "body": "{\r\n    item_pixmap_score->setPixmap(makeMainScore(score));\r\n}",
        "calls": [
          "item_pixmap_score->setPixmap",
          "makeMainScore"
        ]
      },
      {
        "function_name": "Scene::makeEndingScore(int score, int *pos)",
        "params": "(int score, int *pos)",
        "body": "{\r\n    QPainter painter;\r\n    QString strScore = QString::number(score);\r\n    image_endScore.fill(qRgba(0, 0, 0, 0));\r\n    painter.begin(&image_endScore);\r\n\r\n    int zeroWidth = pixmap_smallZero.width();\r\n    int zeroHeight = pixmap_smallZero.height();\r\n\r\n    QPixmap generatedNumber;\r\n    int counter = 0;\r\n    for(; counter < strScore.length(); ++counter)\r\n    {\r\n        generatedNumber.load(QString(IMG_SMALLNUMBER_GENERIC).arg(strScore.mid(counter, 1)));\r\n        painter.drawPixmap(counter * zeroWidth + 3, 0, zeroWidth, zeroHeight, generatedNumber);\r\n    }\r\n    painter.end();\r\n\r\n    if(pos)\r\n        *pos = counter;\r\n\r\n    return QPixmap::fromImage(image_endScore);\r\n}",
        "calls": [
          "QString::number",
          "image_endScore.fill",
          "qRgba",
          "painter.begin",
          "pixmap_smallZero.width",
          "pixmap_smallZero.height",
          "strScore.length",
          "generatedNumber.load",
          "QString(IMG_SMALLNUMBER_GENERIC).arg",
          "QString",
          "strScore.mid",
          "painter.drawPixmap",
          "painter.end",
          "QPixmap::fromImage"
        ]
      },
      {
        "function_name": "Scene::updateGround()",
        "params": "()",
        "body": "{\r\n    if(ground->x() <= -(ground->boundingRect().width() / 2))\r\n    {\r\n        groundPainter->begin(&groundImage);\r\n        groundPainter->drawPixmap(groundImage.width(), 0, groundImage.width() / 2, groundImage.height(), QPixmap::fromImage(groundImage.copy(0, 0, groundImage.width() / 2, groundImage.height())));\r\n        groundPainter->drawPixmap(0, 0, ground->boundingRect().width() / 2, ground->boundingRect().height(), QPixmap::fromImage(groundImage.copy(groundImage.width() / 2, 0, groundImage.width() / 2, groundImage.height())));\r\n        groundPainter->end();\r\n        ground->setPixmap(QPixmap::fromImage(groundImage));\r\n        ground->setPos(0, ground->y());\r\n    }\r\n}",
        "calls": [
          "ground->x",
          "ground->boundingRect().width",
          "ground->boundingRect",
          "groundPainter->begin",
          "groundPainter->drawPixmap",
          "groundImage.width",
          "groundImage.width",
          "groundImage.height",
          "QPixmap::fromImage",
          "groundImage.copy",
          "groundImage.width",
          "groundImage.height",
          "groundPainter->drawPixmap",
          "ground->boundingRect().width",
          "ground->boundingRect",
          "ground->boundingRect().height",
          "ground->boundingRect",
          "QPixmap::fromImage",
          "groundImage.copy",
          "groundImage.width",
          "groundImage.width",
          "groundImage.height",
          "groundPainter->end",
          "ground->setPixmap",
          "QPixmap::fromImage",
          "ground->setPos",
          "ground->y"
        ]
      },
      {
        "function_name": "Scene::fadeGroup(int groupIndex, bool show, int duration, int group2Index)",
        "params": "(int groupIndex, bool show, int duration, int group2Index)",
        "body": "{\r\n    if(!isClickAvailable[0])\r\n        return;\r\n\r\n    isClickAvailable[0] = false;\r\n\r\n    int endMark = 0;\r\n    while(group_item[groupIndex][endMark] != nullptr)\r\n    {\r\n        endMark++;\r\n    }\r\n\r\n    opacityEffectGroup[0] = new QGraphicsOpacityEffect*[endMark];\r\n    opacityAnimGroup[0] = new QPropertyAnimation*[endMark];\r\n    for(int k = 0; k < endMark; k++)\r\n    {\r\n        opacityEffectGroup[0][k] = new QGraphicsOpacityEffect(this);\r\n        opacityAnimGroup[0][k] = new QPropertyAnimation(opacityEffectGroup[0][k], \"opacity\", this);\r\n        group_item[groupIndex][k]->setGraphicsEffect(opacityEffectGroup[0][k]);\r\n\r\n        if(!group_item[groupIndex][k]->isVisible())\r\n        {\r\n            group_item[groupIndex][k]->show();\r\n        }\r\n\r\n        group_item[groupIndex][k]->setOpacity(1.0);\r\n\r\n        if(show)\r\n        {\r\n            opacityAnimGroup[0][k]->setStartValue(0.0);\r\n            opacityAnimGroup[0][k]->setEndValue(1.0);\r\n        }\r\n        else\r\n        {\r\n            opacityAnimGroup[0][k]->setStartValue(1.0);\r\n            opacityAnimGroup[0][k]->setEndValue(0.0);\r\n        }\r\n\r\n        QObject::connect(opacityAnimGroup[0][k], &QPropertyAnimation::finished, [=](){\r\n               group_item[groupIndex][k]->setGraphicsEffect(nullptr);\r\n               if(!show)\r\n               {\r\n                   group_item[groupIndex][k]->hide();\r\n               }\r\n               if(group2Index == -1)\r\n                isClickAvailable[0] = true;\r\n            });\r\n\r\n        opacityAnimGroup[0][k]->setEasingCurve(QEasingCurve::Linear);\r\n        opacityAnimGroup[0][k]->setDuration(duration);\r\n\r\n        opacityAnimGroup[0][k]->start(QAbstractAnimation::DeleteWhenStopped);\r\n    }\r\n\r\n    if(group2Index != -1)\r\n    {\r\n        int endMark2 = 0;\r\n        while(group_item[group2Index][endMark2] != nullptr)\r\n        {\r\n            endMark2++;\r\n        }\r\n        opacityEffectGroup[1] = new QGraphicsOpacityEffect*[endMark2];\r\n        opacityAnimGroup[1] = new QPropertyAnimation*[endMark2];\r\n\r\n\r\n        for(int k = 0; k < endMark2; k++)\r\n        {\r\n            opacityEffectGroup[1][k] = new QGraphicsOpacityEffect(this);\r\n            opacityAnimGroup[1][k] = new QPropertyAnimation(opacityEffectGroup[1][k], \"opacity\", this);\r\n            group_item[group2Index][k]->setGraphicsEffect(opacityEffectGroup[1][k]);\r\n\r\n            if(!group_item[group2Index][k]->isVisible())\r\n            {\r\n                group_item[group2Index][k]->show();\r\n            }\r\n\r\n            group_item[group2Index][k]->setOpacity(1.0);\r\n\r\n            if(show)\r\n            {\r\n                opacityAnimGroup[1][k]->setStartValue(1.0);\r\n                opacityAnimGroup[1][k]->setEndValue(0.0);\r\n            }\r\n            else\r\n            {\r\n                opacityAnimGroup[1][k]->setStartValue(0.0);\r\n                opacityAnimGroup[1][k]->setEndValue(1.0);\r\n            }\r\n\r\n            QObject::connect(opacityAnimGroup[1][k], &QPropertyAnimation::finished, [=](){\r\n                   group_item[group2Index][k]->setGraphicsEffect(nullptr);\r\n                   if(show)\r\n                   {\r\n                       group_item[group2Index][k]->hide();\r\n                   }\r\n                   isClickAvailable[0] = true;\r\n                });\r\n\r\n            opacityAnimGroup[1][k]->setEasingCurve(QEasingCurve::Linear);\r\n            opacityAnimGroup[1][k]->setDuration(duration);\r\n\r\n            opacityAnimGroup[1][k]->start(QAbstractAnimation::DeleteWhenStopped);\r\n        }\r\n    }\r\n\r\n    // Not the best garbage collector but better than nothing...\r\n    // Fix this later!\r\n    QTimer::singleShot(duration + 5, [this, group2Index]() {\r\n        delete[] opacityEffectGroup[0];\r\n        delete[] opacityAnimGroup[0];\r\n        if(group2Index != -1)\r\n        {\r\n            delete[] opacityEffectGroup[1];\r\n            delete[] opacityAnimGroup[1];\r\n        }\r\n    });\r\n}",
        "calls": [
          "group_item[groupIndex][k]->setGraphicsEffect",
          "group_item[groupIndex][k]->isVisible",
          "group_item[groupIndex][k]->show",
          "group_item[groupIndex][k]->setOpacity",
          "opacityAnimGroup[0][k]->setStartValue",
          "opacityAnimGroup[0][k]->setEndValue",
          "opacityAnimGroup[0][k]->setStartValue",
          "opacityAnimGroup[0][k]->setEndValue",
          "QObject::connect",
          "group_item[groupIndex][k]->setGraphicsEffect",
          "group_item[groupIndex][k]->hide",
          "opacityAnimGroup[0][k]->setEasingCurve",
          "opacityAnimGroup[0][k]->setDuration",
          "opacityAnimGroup[0][k]->start",
          "group_item[group2Index][k]->setGraphicsEffect",
          "group_item[group2Index][k]->isVisible",
          "group_item[group2Index][k]->show",
          "group_item[group2Index][k]->setOpacity",
          "opacityAnimGroup[1][k]->setStartValue",
          "opacityAnimGroup[1][k]->setEndValue",
          "opacityAnimGroup[1][k]->setStartValue",
          "opacityAnimGroup[1][k]->setEndValue",
          "QObject::connect",
          "group_item[group2Index][k]->setGraphicsEffect",
          "group_item[group2Index][k]->hide",
          "opacityAnimGroup[1][k]->setEasingCurve",
          "opacityAnimGroup[1][k]->setDuration",
          "opacityAnimGroup[1][k]->start",
          "QTimer::singleShot"
        ]
      },
      {
        "function_name": "Scene::flash(const QColor &color, int duration, const QEasingCurve &curve)",
        "params": "(const QColor &color, int duration, const QEasingCurve &curve)",
        "body": "{\r\n    if(!isClickAvailable[1])\r\n        return;\r\n\r\n    QImage refImg = QImage(width(), height(), QImage::Format_RGB32);\r\n    QPainter painter;\r\n\r\n    isClickAvailable[1] = false;\r\n\r\n    opacityEffect = new QGraphicsOpacityEffect(this);\r\n    opacityAnim = new QPropertyAnimation(opacityEffect, \"opacity\", this);\r\n\r\n    item_pixmap_flash = new QGraphicsPixmapItem();\r\n    item_pixmap_flash->setGraphicsEffect(opacityEffect);\r\n\r\n    flashStatus = false;\r\n\r\n    painter.begin(&refImg);\r\n    painter.fillRect(QRect(0, 0, width(), height()), color);\r\n    painter.end();\r\n\r\n    item_pixmap_flash->setPixmap(QPixmap::fromImage(refImg));\r\n\r\n    addItem(item_pixmap_flash);\r\n\r\n    opacityAnim->setStartValue(0.0);\r\n    opacityAnim->setDuration(duration);\r\n    opacityAnim->setEasingCurve(curve);\r\n    opacityAnim->setEndValue(1.0);\r\n\r\n    connect(opacityAnim, &QPropertyAnimation::finished, [=](){\r\n        if(flashStatus == false)\r\n        {\r\n            QTimer::singleShot(75, [=]() {\r\n               if(opacityAnim)\r\n               {\r\n                    opacityAnim->setStartValue(1.0);\r\n                    opacityAnim->setEndValue(0.0);\r\n                    opacityAnim->setDuration(duration);\r\n                    opacityAnim->start(QAbstractAnimation::DeleteWhenStopped);\r\n               }\r\n            });\r\n            flashStatus = true;\r\n        }\r\n        else\r\n        {\r\n            removeItem(item_pixmap_flash);\r\n            delete item_pixmap_flash;\r\n            flashStatus = false;\r\n            isClickAvailable[1] = true;\r\n        }\r\n});\r\n    opacityAnim->start();\r\n}",
        "calls": [
          "QImage",
          "width",
          "height",
          "item_pixmap_flash->setGraphicsEffect",
          "painter.begin",
          "painter.fillRect",
          "QRect",
          "width",
          "height",
          "painter.end",
          "item_pixmap_flash->setPixmap",
          "QPixmap::fromImage",
          "addItem",
          "opacityAnim->setStartValue",
          "opacityAnim->setDuration",
          "opacityAnim->setEasingCurve",
          "opacityAnim->setEndValue",
          "connect",
          "QTimer::singleShot",
          "opacityAnim->setStartValue",
          "opacityAnim->setEndValue",
          "opacityAnim->setDuration",
          "opacityAnim->start",
          "removeItem",
          "opacityAnim->start"
        ]
      },
      {
        "function_name": "Scene::mousePressEvent(QGraphicsSceneMouseEvent *event)",
        "params": "(QGraphicsSceneMouseEvent *event)",
        "body": "{\r\n    if((!isClickAvailable[0] || !isClickAvailable[1]) && !(game->isGameActuallyStarted()))\r\n    {\r\n        event->accept();\r\n        return;\r\n    }\r\n\r\n    QPointF pos = event->scenePos();\r\n\r\n    for(unsigned int k = 0; k < ARRAY_SIZE(button); ++k)\r\n    {\r\n        QApplication::processEvents();\r\n        if (button[k] == nullptr)\r\n            break;\r\n        if(itemAt(pos, game->graphicsView->transform()) == button[k])\r\n        {\r\n            button[k]->invoke();\r\n            return;\r\n        }\r\n    }\r\n\r\n    game->clickEvent();\r\n    event->accept();\r\n}",
        "calls": [
          "game->isGameActuallyStarted",
          "event->accept",
          "event->scenePos",
          "ARRAY_SIZE",
          "QApplication::processEvents",
          "itemAt",
          "game->graphicsView->transform",
          "button[k]->invoke",
          "game->clickEvent",
          "event->accept"
        ]
      },
      {
        "function_name": "Scene::mouseDoubleClickEvent(QGraphicsSceneMouseEvent *event)",
        "params": "(QGraphicsSceneMouseEvent *event)",
        "body": "{\r\n    mousePressEvent(event);\r\n}",
        "calls": [
          "mousePressEvent"
        ]
      },
      {
        "function_name": "Scene::keyPressEvent(QKeyEvent *event)",
        "params": "(QKeyEvent *event)",
        "body": "{\r\n    if((!isClickAvailable[0] || !isClickAvailable[1]) && !(game->isGameActuallyStarted()))\r\n    {\r\n        event->accept();\r\n        return;\r\n    }\r\n    game->clickEvent();\r\n    event->accept();\r\n}",
        "calls": [
          "game->isGameActuallyStarted",
          "event->accept",
          "game->clickEvent",
          "event->accept"
        ]
      }
    ]
  },
  "Flappy-Bird-Qt\\source\\Scene\\Scene.h": {
    "includes": [
      "#include \"common.h\"\r\n",
      "#include <QGraphicsScene>\r\n"
    ],
    "functions": []
  },
  "Flappy-Bird-Qt\\source\\Sound\\Sound.cpp": {
    "includes": [
      "#include \"Sound.h\"\r\n",
      "#include \"Game/Game.h\"\r\n"
    ],
    "functions": [
      {
        "function_name": "Sound::playIfEnabled()",
        "params": "()",
        "body": "{\r\n    if(game->isSoundEnabled())\r\n    {\r\n        play();\r\n    }\r\n}",
        "calls": [
          "game->isSoundEnabled",
          "play"
        ]
      }
    ]
  },
  "Flappy-Bird-Qt\\source\\Sound\\Sound.h": {
    "includes": [
      "#include <QSound>\r\n"
    ],
    "functions": [
      {
        "function_name": "Sound(const QString& filename, Game *parent_game)",
        "params": "(const QString& filename, Game *parent_game)",
        "body": "{ }",
        "calls": []
      }
    ]
  },
  "Flappy-Bird-Qt\\source\\StrobeDialog\\StrobeDialog.cpp": {
    "includes": [
      "#include \"StrobeDialog.h\"\r\n",
      "#include <QLabel>\r\n",
      "#include <QLayout>\r\n",
      "#include <QTimer>\r\n",
      "#include \"strobe-api/strobe/strobe-core.h\"\r\n"
    ],
    "functions": [
      {
        "function_name": "StrobeDialog::StrobeDialog(StrobeAPI *strobeAPI, QWidget *parent, int posX, int posY, int interval)",
        "params": "(StrobeAPI *strobeAPI, QWidget *parent, int posX, int posY, int interval)",
        "body": "{\r\n    setMinimumSize(STROBE_DIALOG_DEFAULT_WIDTH, STROBE_DIALOG_DEFAULT_HEIGHT);\r\n    setWindowTitle(STROBE_DIALOG_TITLE);\r\n\r\n    layout = new QVBoxLayout(this);\r\n    info = new QLabel(this);\r\n    layout->addWidget(info);\r\n    setLayout(layout);\r\n\r\n    setPos(posX, posY);\r\n\r\n    show();\r\n\r\n    updateTimer = new QTimer(this);\r\n    connect(updateTimer, SIGNAL(timeout()), this, SLOT(updateInfo()));\r\n    updateTimer->setInterval(interval);\r\n    updateTimer->start();\r\n}",
        "calls": [
          "setMinimumSize",
          "setWindowTitle",
          "layout->addWidget",
          "setLayout",
          "setPos",
          "show",
          "connect",
          "SIGNAL",
          "timeout",
          "SLOT",
          "updateInfo",
          "updateTimer->setInterval",
          "updateTimer->start"
        ]
      },
      {
        "function_name": "StrobeDialog::setInterval(int interval)",
        "params": "(int interval)",
        "body": "{\r\n    updateTimer->setInterval(interval);\r\n}",
        "calls": [
          "updateTimer->setInterval"
        ]
      },
      {
        "function_name": "StrobeDialog::startUpdate()",
        "params": "()",
        "body": "{\r\n    if(!updateTimer->isActive())\r\n        updateTimer->start();\r\n}",
        "calls": [
          "updateTimer->isActive",
          "updateTimer->start"
        ]
      },
      {
        "function_name": "StrobeDialog::stopUpdate()",
        "params": "()",
        "body": "{\r\n    if(updateTimer->isActive())\r\n        updateTimer->stop();\r\n}",
        "calls": [
          "updateTimer->isActive",
          "updateTimer->stop"
        ]
      },
      {
        "function_name": "StrobeDialog::setPos(int posX, int posY)",
        "params": "(int posX, int posY)",
        "body": "{\r\n    setGeometry(posX, posY, width(), height());\r\n}",
        "calls": [
          "setGeometry",
          "width",
          "height"
        ]
      },
      {
        "function_name": "StrobeDialog::updateInfo()",
        "params": "()",
        "body": "{\r\n    const char *src = strobe->getDebugInformation();\r\n    QString Q_src(src);\r\n\r\n    info->setText(Q_src);\r\n}",
        "calls": [
          "strobe->getDebugInformation",
          "info->setText"
        ]
      }
    ]
  },
  "Flappy-Bird-Qt\\source\\StrobeDialog\\StrobeDialog.h": {
    "includes": [
      "#include \"common.h\"\r\n",
      "#include <QDialog>\r\n"
    ],
    "functions": []
  },
  "Flappy-Bird-Qt\\source\\View\\View.cpp": {
    "includes": [
      "#include \"View.h\"\r\n",
      "#include <QTimer>\r\n",
      "#include <QElapsedTimer>\r\n",
      "#include <QPaintEvent>\r\n",
      "#include <QPainter>\r\n",
      "#include \"strobe-api/strobe/strobe-core.h\"\r\n"
    ],
    "functions": [
      {
        "function_name": "View::View(QWidget *parent, StrobeAPI *strobeAPI)",
        "params": "(QWidget *parent, StrobeAPI *strobeAPI)",
        "body": "{\r\n    frameCount = 0;\r\n    tick = 0;\r\n\r\n    fpsTimer = new QElapsedTimer();\r\n    fpsTimer->start();\r\n\r\n#ifndef STROBE_DISABLED\r\n    if(strobe != nullptr)\r\n    {\r\n        strobeFPSUpdater = new QTimer(this);\r\n        strobeFPSUpdater->setInterval(25);\r\n        connect(strobeFPSUpdater, &QTimer::timeout, [this]() {\r\n            strobe->setFPS((double)fps());\r\n        });\r\n        strobeFPSUpdater->start();\r\n    }\r\n#endif\r\n}",
        "calls": [
          "fpsTimer->start",
          "strobeFPSUpdater->setInterval",
          "connect",
          "strobe->setFPS",
          "fps",
          "strobeFPSUpdater->start"
        ]
      },
      {
        "function_name": "View::~View()",
        "params": "()",
        "body": "{\r\n    delete fpsTimer;\r\n}",
        "calls": []
      },
      {
        "function_name": "View::paintEvent(QPaintEvent *event)",
        "params": "(QPaintEvent *event)",
        "body": "{\r\n    ++frameCount;\r\n\r\n#ifndef STROBE_DISABLED\r\n    if(strobe != nullptr)\r\n    {\r\n        bool show = strobe->strobe();\r\n        if(show)\r\n            QGraphicsView::paintEvent(event);\r\n        else\r\n        {\r\n            QPainter painter(viewport());\r\n            painter.fillRect(event->rect(), Qt::black);\r\n        }\r\n    }\r\n    else\r\n    {\r\n        QGraphicsView::paintEvent(event);\r\n    }\r\n#else\r\n    QGraphicsView::paintEvent(event);\r\n#endif\r\n}",
        "calls": [
          "strobe->strobe",
          "QGraphicsView::paintEvent",
          "viewport",
          "painter.fillRect",
          "event->rect",
          "QGraphicsView::paintEvent",
          "QGraphicsView::paintEvent"
        ]
      },
      {
        "function_name": "View::fps()",
        "params": "()",
        "body": "{\r\n    float elapsedTime = (float)(fpsTimer->elapsed());\r\n    int _frameCount = frameCount;\r\n\r\n    if((elapsedTime >= 1000.0))\r\n    {\r\n        fpsTimer->restart();\r\n        frameCount = 0;\r\n    }\r\n\r\n    return (1000.0f * _frameCount / elapsedTime);\r\n}",
        "calls": [
          "fpsTimer->elapsed",
          "fpsTimer->restart"
        ]
      }
    ]
  },
  "Flappy-Bird-Qt\\source\\View\\View.h": {
    "includes": [
      "#include \"common.h\"\r\n",
      "#include <QGraphicsView>\r\n",
      "#include <QPainter>\r\n"
    ],
    "functions": []
  }
}